{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "fmota", "created_utc": "1193668416", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "bitwize", "created_utc": "1193676816", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "fmota", "created_utc": "1193685830", "children": [{"controversiality": 0, "retrieved_on": 1427425047, "subreddit_id": "t5_2fwo", "archived": true, "score": 1, "link_id": "t3_5zchm", "downs": 0, "name": "t1_c02c0zi", "created_utc": "1193689192", "score_hidden": false, "id": "c02c0zi", "author": "bitwize", "author_flair_text": null, "distinguished": null, "edited": false, "gilded": 0, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02c0ld", "body": "Lol. Sorry, I had recently read a Paul Hsieh article about optimizing comparisons out in order to avoid the branch-misprediction performance hit. First thing that popped into my mind.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c0ld", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5zchm", "retrieved_on": 1427425052, "body": " Heh, I wasn't really thinking of branch mispredictions, but okay. I was in fact thinking of the dynamic comparison that was going on so often -- it's easier for a compiler to optimize `if (diff ^ 1) {...}`   than it is for the compiler to optimize `if (top == bottom) {...} if (top == bottom+1) {...}` ", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02bzgc", "id": "c02c0ld", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02bzgc", "ups": 0, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zchm", "retrieved_on": 1427425066, "score_hidden": false, "id": "c02bzgc", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02byfq", "body": "Because when illustrating a new function to n00bs, branch mispredictions are such a _critical_ concern.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c02byfq", "controversiality": 0, "author_flair_text": null, "ups": 0, "link_id": "t3_5zchm", "retrieved_on": 1427425080, "body": "His factorial function would make more sense with the arguments reversed.\n\nFurthermore, his algorithm makes too many comparisons (in my opinion). Here's my version.\n\n    unsigned int fact(unsigned int end, unsigned int diff)\n    {\n        if (diff ^ 1) {\n            return fact(end, (diff&amp;1) + (diff&gt;&gt;1)) * fact(end-(diff&gt;&gt;1), diff&gt;&gt;1);\n        }\n        return end;\n    }\n\nTo find n!, use `fact(n, n-1)`. There's probably a way of optimizing this. You're welcome to do that. :)", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5zchm", "id": "c02byfq", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193671886", "ups": 3, "gilded": 0, "link_id": "t3_5zchm", "retrieved_on": 1427425074, "score": 3, "score_hidden": false, "id": "c02byuz", "author": "queensnake", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02byuz", "parent_id": "t3_5zchm", "body": "-1 Way too basic and lame. ", "author_flair_css_class": null}