{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192546685", "ups": -8, "gilded": 0, "link_id": "t3_5yf2v", "retrieved_on": 1427426305, "score": -8, "body": "ObQwe1234:\n\n&gt; shit, more shit, and _complete and utter shit_ respectively.\n\n&gt; ugh", "id": "c029hcw", "author": "bitwize", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029hcw", "parent_id": "t3_5yf2v", "score_hidden": false, "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "grauenwolf", "created_utc": "1192552959", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c029i4o", "gilded": 0, "link_id": "t3_5yf2v", "retrieved_on": 1427426295, "score": 3, "score_hidden": false, "id": "c029i4o", "author": "sazj", "created_utc": "1192553715", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 3, "parent_id": "t1_c029i15", "body": "Especially if you use a Lisp / Scheme implementation like *Gambit* that gives you full access low-level primitives needed to generate near optimal machine code", "author_flair_css_class": null}, {"created_utc": "1192568002", "downs": 0, "subreddit": "programming", "archived": true, "ups": 1, "gilded": 0, "link_id": "t3_5yf2v", "retrieved_on": 1427426273, "score": 1, "controversiality": 0, "body": "Part of me does.\n\nThe obvious advantage is that Lisp is a completely dynamic, fast, safe runtime, but not crippled by weak, static type systems like the managed C dialects out there.\n\nOTOH, I like the idea that a language/compiler can optimize stuff that the safe, managed runtime won't optimize.  Yes, Lisp has declarations, but they are unsafe.\n\nBut for \"scripting\" (hate that word) languages or non-C dialects, Lisp would truly shine.", "author": "[deleted]", "author_flair_text": null, "distinguished": null, "edited": false, "id": "c029juk", "subreddit_id": "t5_2fwo", "score_hidden": false, "parent_id": "t1_c029i15", "name": "t1_c029juk", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 6, "controversiality": 0, "archived": true, "link_id": "t3_5yf2v", "retrieved_on": 1427426296, "id": "c029i15", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029i15", "parent_id": "t3_5yf2v", "body": "&gt; Another reason not mentioned is that Lisp can become a common intermediate form allowing several source languages to interoperate. So Ruby or Smalltalk could be compiled to Lisp then Lisp to byte code. \r\n\r\nI really like that idea.", "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427426248, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029lqr", "gilded": 0, "link_id": "t3_5yf2v", "downs": 0, "score": 2, "score_hidden": false, "body": "Having a representation of a parse tree is not Lisp.  Most (all?) languages can be represented with an AST.  The semantics of Ruby (message passing, everything is an object) are not the same as the semantics of Lisp (functions w/ closures).", "author": "uedauhes", "created_utc": "1192592660", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 2, "parent_id": "t3_5yf2v", "id": "c029lqr", "author_flair_css_class": null}