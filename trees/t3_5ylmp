{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "seliopou", "created_utc": "1192729087", "children": [{"controversiality": 0, "retrieved_on": 1427426099, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029x9b", "gilded": 0, "link_id": "t3_5ylmp", "downs": 0, "score": 4, "score_hidden": false, "body": "&gt; I haven't written Java code in a while, so I don't know what the state of autoboxing is in Java.\n\n1.5 adds some autoboxing:\n\nhttp://java.sun.com/j2se/1.5.0/docs/guide/language/autoboxing.html \n\nYou can do this:\n\n    return new Integer(length0).compareTo(length1);\n\nBut you still can't do things like:\n\n    return length0.compareTo(length1);\n\nOr:\n\n    return 5.compareTo(3);\n\nThe former gets you an \"int cannot be dereferenced\" compile error, the latter a \"not a statement\" compile error.", "author": "sblinn", "created_utc": "1192733512", "distinguished": null, "edited": true, "author_flair_text": null, "subreddit": "programming", "ups": 4, "parent_id": "t1_c029wli", "id": "c029x9b", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5ylmp", "retrieved_on": 1427426108, "id": "c029wli", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029wli", "parent_id": "t3_5ylmp", "body": "If he's look for short code in the sorting example, he could shorten it a bunch by just doing:\n\nreturn new Integer(length0).compareTo(new Integer(length1));\n\nI haven't written Java code in a while, so I don't know what the state of autoboxing is in Java.", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 11, "author": "cgibbard", "created_utc": "1192731547", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -6, "author": "happyhappyhappy", "created_utc": "1192732062", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029x2l", "gilded": 0, "link_id": "t3_5ylmp", "retrieved_on": 1427426101, "score": 4, "score_hidden": false, "body": "Functional languages tend to have much better support for parametric polymorphism than Java's generics.", "author": "[deleted]", "created_utc": "1192732406", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 4, "parent_id": "t1_c029x0z", "id": "c029x2l", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 5, "author": "cgibbard", "created_utc": "1192732689", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -2, "author": "seliopou", "created_utc": "1192733230", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "cgibbard", "created_utc": "1192733557", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": -1, "author": "seliopou", "created_utc": "1192734315", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 4, "author": "cgibbard", "created_utc": "1192735270", "children": [{"controversiality": 0, "retrieved_on": 1427426094, "subreddit_id": "t5_2fwo", "created_utc": "1192736588", "ups": 0, "gilded": 0, "link_id": "t3_5ylmp", "downs": 0, "score": 0, "id": "c029xo4", "author": "seliopou", "archived": true, "distinguished": null, "edited": false, "body": "&gt;Also, it doesn't just give simple dynamic dispatch, but functions which use typeclass polymorphic functions can themselves become typeclass polymorphic.\n\nThis is also possible using dynamic dispatch and interfaces.\n\nTo put this to an end I will say this: I am guilty of overstating my case, and I think you're guilty of being disingenuous.\n\nObviously dynamic dispatch doesn't do everything that type classes do. But it's also not correct to say that Java has nothing comparable to type classes. ", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029xo4", "parent_id": "t1_c029xho", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1192736875", "name": "t1_c029xpx", "gilded": 0, "link_id": "t3_5ylmp", "retrieved_on": 1427426093, "score": -1, "score_hidden": false, "id": "c029xpx", "author": "seliopou", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": -1, "parent_id": "t1_c029xho", "body": "I didn't say type classes are plain ad-hoc polymorphsim. I said that they were developed to solve to the problem of ad-hoc polymorphism in a statically typed language.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 4, "name": "t1_c029xho", "controversiality": 0, "archived": true, "link_id": "t3_5ylmp", "retrieved_on": 1427426096, "score_hidden": false, "id": "c029xho", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c029xd7", "body": " Yeah, but the types of dynamic dispatch available are fundamentally different.\n\nAlso, it doesn't just give simple dynamic dispatch, but functions which use typeclass polymorphic functions can themselves become typeclass polymorphic.\n\nIt's not really plain ad-hoc polymorphism. A better name for it is bounded parametric polymorphism, since it has more in common with that than the usual sort of ad-hoc polymorphism where the implementation to be used is determined only at the call site.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192735272", "ups": 3, "gilded": 0, "link_id": "t3_5ylmp", "retrieved_on": 1427426096, "score": 3, "body": "Sure, but as cgibbard pointed out the dynamic dispatch is more flexible when the methods are not part of the objects but travel separately.  (Existentials allow you to package them together if you want.)\n", "author": "augustss", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029xhq", "parent_id": "t1_c029xd7", "score_hidden": false, "id": "c029xhq"}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": -1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ylmp", "retrieved_on": 1427426098, "body": "Outside of the higher-kinded type classes and multi-parameter type classes, the main reason you use type classes is for the dynamic dispatch. Remember, the whole reason type classes were developed was to solve the problem of ad-hoc polymorphism.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029xd7", "parent_id": "t1_c029x9n", "id": "c029xd7", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029x9n", "ups": 3, "controversiality": 0, "archived": true, "link_id": "t3_5ylmp", "retrieved_on": 1427426099, "score_hidden": false, "id": "c029x9n", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c029x7o", "body": "No, that's not really equivalent.\n\nJava's dynamic dispatch has the methods carried along with the data. Typeclasses have the methods carried separately from the data they act on.\n\nAs a result of this, the operation which is performed can depend on the type of the desired result, not just the inputs to the operation.\n\nThat's just the first major difference. If you start talking about constructor classes or multiparameter typeclasses, then you can get even farther away from anything which looks like Java.\n\nFor example, with multiparameter classes, the operations chosen can vary based on any number of types involved in the operation. ", "author_flair_css_class": null}], "subreddit": "programming", "ups": -2, "name": "t1_c029x7o", "controversiality": 0, "archived": true, "link_id": "t3_5ylmp", "retrieved_on": 1427426100, "score_hidden": false, "id": "c029x7o", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029x40", "body": "&gt;Haskell has typeclasses, Java doesn't have anything like that.\n\nThe equivalent feature of Java's object system to type classes is dynamic dispatch.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 0, "gilded": 0, "link_id": "t3_5ylmp", "retrieved_on": 1427426021, "score": 0, "created_utc": "1192809397", "body": "Please note that I did not say anything about Java.  I said \"the type system of most functional languages is pretty much the same.\"  That is, Haskell, Clean, ML, Miranda, etc.", "author": "happyhappyhappy", "author_flair_text": null, "distinguished": null, "edited": false, "id": "c02a39l", "subreddit_id": "t5_2fwo", "score_hidden": false, "parent_id": "t1_c029x40", "name": "t1_c02a39l", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029x40", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 5, "link_id": "t3_5ylmp", "retrieved_on": 1427426101, "body": " You're wrong on both counts.\n\nHaskell's type system in particular has universally quantified type variables (parametric polymorphism). Java recently got support for \"generics\" which is essentially parametric polymorphism, but they're somewhat crippled and not all that commonly used. Haskell has typeclasses, Java doesn't have anything like that. Algebraic data types. Java has nothing remotely like that.\n\nIf you start looking at what's in GHC, things like GADTs, existentially quantified types, higher rank types, type families, and so on, there's just no comparison.\n\nYou can easily have destructively updated objects in a purely functional language, via monads which allow you to express those imperative computations which manipulate those structures. You can even have a monad like ST, which will let you do all the imperative stuff you want involving mutable references and so on, as long as there are no *real* side effects, and it will wrap that up into a pure function for you, and it's not really any harder than using an ordinary imperative language. It's only harder *in comparison* to using immutable data structures which you can reason about equationally, and for which you typically only pay a logarithmic factor (essentially part of the constant factor). But this is really true in any language, only that in most imperative languages, equational reasoning is hard enough no matter what you do that people don't bother to think that way.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c029x0z", "id": "c029x40", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029x0z", "score_hidden": false, "controversiality": 0, "archived": true, "ups": -6, "link_id": "t3_5ylmp", "retrieved_on": 1427426103, "id": "c029x0z", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029wy4", "body": "Well, the type system of most functional languages is pretty much the same, except that type inference removes the need to declare types in simple cases (but not in cases where you need named variants).\n\nOh, and you can't easily have destructively updated objects in purely functional language, and they're handy for a large class of problems.", "author_flair_css_class": null}, {"distinguished": null, "controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02a1au", "gilded": 0, "link_id": "t3_5ylmp", "retrieved_on": 1427426048, "score": 1, "score_hidden": false, "id": "c02a1au", "author": "[deleted]", "created_utc": "1192780147", "author_flair_text": null, "edited": false, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c029wy4", "body": "[deleted]", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029wy4", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 11, "link_id": "t3_5ylmp", "retrieved_on": 1427426103, "body": " If your primary example of a static type system is Java's, you probably shouldn't write an article about how static type systems in general suck.\n\nEdit: I'm being serious here. There are many static type systems out there which are much more expressive and concise and useful than Java's. Comparing a fairly nice dynamically typed language like Smalltalk to Java and then concluding something in general about static and dynamic type systems is just completely unfair to static typing. ", "archived": true, "distinguished": null, "edited": true, "parent_id": "t3_5ylmp", "id": "c029wy4", "author_flair_css_class": null}