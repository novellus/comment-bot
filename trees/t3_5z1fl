{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "w-g", "created_utc": "1193254909", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193258471", "ups": 6, "gilded": 0, "link_id": "t3_5z1fl", "retrieved_on": 1427425544, "score": 6, "body": "It matters quite a bit, I'm sorry to say. Try using MySQL from CLISP, for example.\n\nI like Lisp, but it can be hard to get the environment working, particularly for those in Windows (and lots of folks are). Choices may ultimately be valuable, but they make it confusing at the start. Lisp-in-a-box had the right idea.", "id": "c02b42x", "author": "adamc", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02b42x", "parent_id": "t1_c02b3lc", "score_hidden": false, "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "eadmund", "created_utc": "1193266965", "children": [{"controversiality": 0, "retrieved_on": 1427425333, "subreddit_id": "t5_2fwo", "archived": true, "gilded": 0, "link_id": "t3_5z1fl", "downs": 0, "score": 1, "score_hidden": false, "body": "Thanks for the tip, SBCL will be my post ELisp Lisp.", "author": "ndanger", "created_utc": "1193373416", "distinguished": null, "edited": false, "id": "c02bev0", "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02b507", "name": "t1_c02bev0", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02b507", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 6, "link_id": "t3_5z1fl", "retrieved_on": 1427425532, "body": "&gt; Why shouldn't I choose which Common Lisp implementation I will use?\n\n_You_ should be able to choose, just as one can choose between Python, Jython and Iron Python.  But a newbie doesn't _have_ to choose between those, because there is a dominant reference implementation: Python.\n\nThe same should be true of Common Lisp.\n\n&gt; It really doesn't matter which, until you're an expert who needs something very specific.\n\nHahaha.  Far too often, library A supports CMUCL and SBCL, library B supports CMUCL and CLISP, library C supports CLISP and LispWorks, and I need to use all three.\n\nFortunately, SBCL is becoming the free Lisp of choice.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02b3lc", "id": "c02b507", "author_flair_css_class": null}], "subreddit": "programming", "ups": 2, "name": "t1_c02b3lc", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5z1fl", "retrieved_on": 1427425550, "score_hidden": false, "body": "A few comments...\n\n&gt; * Dominant (reference) implementation: no having to decide between CMUCL and SBCL\n\nI like freedom. I can pick any brand of cellphone, car or bike. Why shouldn't I choose which Common Lisp implementation I will use?\n\n&gt; * Easy installation: binaries, ports\u2026 autoconf/automake maybe\n\nautoconf/automake? Easy? *If* you get all dependencies right. Otherwise you're in hell.\n\n&gt; LISP and Scheme have too many implementations. That\u2019s why all of my LISP knowledge comes from customizing Emacs.\n\nJust pick one (*any* one). It really doesn't matter which, until you're an expert who needs something very specific.\n\n&gt; Forth was difficult for me to install,\n\napt-get install kforth gforth\n\nOK, that's cheating. If Forth wasn't available from my Linux distribution, I'd need to compile manually... :)\n\n", "archived": true, "distinguished": null, "edited": true, "parent_id": "t3_5z1fl", "id": "c02b3lc", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "dons", "created_utc": "1193255706", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "[deleted]", "created_utc": "1193263663", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 5, "author": "dons", "created_utc": "1193264453", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c02b4wa", "gilded": 0, "link_id": "t3_5z1fl", "retrieved_on": 1427425533, "score": 4, "score_hidden": false, "body": "In the vein of the original article, I'd define a useful small program as one which can solve a a problem that a beginning user is likely to have a need to solve.  That problem needs to be self-contained and live within the user's normal environment to induce the user to continue.\n\nThe one-liners shown don't do that.  Splitting a word is a building block, it's not a problem of itself.  Text search, same thing, especially since it's within a string  Fibonacci, prime numbers... simulating cond?  \n\nThe reimplementation of Unix commands is perhaps more interesting, but by itself, you're reimplementing tools you already have.  \n\nCompare that with the types of simple programs we see in Perl and Python.  \"I have a bunch of files, and I want to rename them all according to some pattern.\"  Common problem, easy solution.  \"I've got a log file full of email addresses, I need to strip them out from the log entries, remove duplicates, and add them to a database.\"  Again, fairly simple, fairly small, really useful.\n\nWhen Haskell can compete on those types of problems, it'll be easier to induce people to learn it.  (Same with CL, my fav language....)", "author": "[deleted]", "created_utc": "1193265673", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 4, "parent_id": "t1_c02b4sh", "id": "c02b4wa", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02b4sh", "ups": 5, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5z1fl", "retrieved_on": 1427425535, "score_hidden": false, "body": "Reimplementing a 100 line unix command in 12 characters seems a reasonable, useful example for beginners. The one liners also show good power/weight ratios (I particularly like the powerset definition using a list monad).\n\nYou've asserted that these simple programs aren't useful -- however, they're taken from real programs, so I have to dispute this -- clearly they're useful to someone, or they'd not have been written.\n\nDo you simply work in a different application domain to the ones presented? What does *useful* mean to you?", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02b4pk", "id": "c02b4sh", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 0, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5z1fl", "retrieved_on": 1427425536, "body": "So, you can reimplement existing Unix commands.  Ok, cute, but I hardly consider that very useful.  And the \"stunning one-liners\" don't seem to be of much utility.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02b4pk", "parent_id": "t1_c02b3py", "id": "c02b4pk", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193373288", "name": "t1_c02beur", "gilded": 0, "link_id": "t3_5z1fl", "retrieved_on": 1427425333, "score": 1, "score_hidden": false, "body": " I'm the author (but not the submitter)\n\nActually I think simple programs *should* do IO, as in the scripting language example.  I like fancy one-liners but don't think of them as learning tools as much as golf for experienced users.  The unix tools look pretty neat, I'll have to give those a look.  \n\nAnyway, I updated the entry.  Thanks for the links!", "author": "ndanger", "author_flair_text": null, "distinguished": null, "edited": true, "archived": true, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02b3py", "id": "c02beur", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5z1fl", "retrieved_on": 1427425549, "id": "c02b3py", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02b3py", "parent_id": "t3_5z1fl", "body": "I'd just point out that only someone who hadn't programmed Haskell would say\n\n&gt; simple programs are not useful\n\ngiven, e.g. http://haskell.org/haskellwiki/Simple_Unix_tools\nand the endless stream of [stunning one liners](http://haskell.org/haskellwiki/Blow_your_mind) we find. If anything, short and *useful* characterises too much of the Haskell tutorial space.\n\nThe author obviously fell for the stereotype that simple programs aren't allowed to do IO. That's so 1994...", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193268839", "ups": 1, "gilded": 0, "link_id": "t3_5z1fl", "retrieved_on": 1427425530, "score": 1, "score_hidden": false, "body": "his previous post of 'Adventures in Forth' was a dangerous blog post with very little research or regard for the motivations of the initial implementation chosen.\n\nclearly in this new post he's attempting once again to limit perspective without a full understanding of the semantics of what he's saying.", "author": "[deleted]", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02b55t", "parent_id": "t3_5z1fl", "id": "c02b55t", "author_flair_css_class": null}