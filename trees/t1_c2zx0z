{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "[deleted]", "created_utc": "1192457562", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "antonivs", "created_utc": "1192472867", "children": [{"controversiality": 0, "retrieved_on": 1427426365, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029cr1", "gilded": 0, "link_id": "t3_2zwb2", "downs": 0, "score": 1, "score_hidden": false, "body": "I agree. Using closures to emulate objects by abusing mutability is not interesting. For all the reasons that make objects not interesting :). However, using immutable closures, aka higher order functions, is very interesting and we have barely started to understand their power.\n\nObjects: Dynamic run-time replaceability for modules. Engineering crutch.\n\nClosures/HOF: Full power of mathematical logic.\n\nLess is more.", "author": "[deleted]", "created_utc": "1192480410", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029brw", "id": "c029cr1", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029brw", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_2zwb2", "retrieved_on": 1427426377, "body": " &gt; to my limited experience, closures compose in substantially more generic and interesting ways than multi-slotted objects\n\nThis implies that you're thinking in terms of a particular expression of multi-slotted objects in particular languages.\n\nNote that the original comment raised this very point, in the first paragraph.  However, it also provides a counterpoint, which is valid for more expressive object languages, such as Smalltalk.\n\n&gt; closures (if used right) have also the nice property of being immutable, thus one can actually reason about them.\n\nOne could equally say that about objects \"if used right\".  In fact, Alan Kay has made comments along those lines.\n\nHowever, one of the main uses of closures in languages like ML, Scheme, and Lisp is precisely to exploit their ability to encapsulate mutable variables.  I suspect you're using 'closure' as a synonym for higher-order function here, which is misleading.\n\nAgain, thinking in terms of mainstream corruptions of these ideas doesn't help you understand the underlying situation.  You can't fully learn theory by extrapolating from limited examples.  The original comment was in the context of language design, and doesn't have much to do with how well e.g. Python or Java implements such ideas.\n ", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c0299xc", "id": "c029brw", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c0299xc", "controversiality": 0, "archived": true, "link_id": "t3_2zwb2", "retrieved_on": 1427426401, "score_hidden": false, "id": "c0299xc", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c2zx0z", "body": "Nice :)\r\n\r\nGoing back to the meat of the article, the claim is that one can easily implement objects with closures and viceversa. You have just shown that we can do the same for brainfuck + a reasonable preprocessor. Thus my point stands, the discussion is moot as stated.\r\n\r\nHowever. Less is more; to my limited experience, closures compose in substantially more generic and interesting ways than multi-slotted objects. Less is more; closures (if used right) have also the nice property of being immutable, thus one can actually reason about them. Not to mention that the only interesting thing about object theory is subtyping polymorphism, which is a mere crutch. The content of the methods is never proved covariant, not even in theory. Serious question: What does 'covariant' actually mean, i.e. what is its formal semantics, in context of mutable entities?", "author_flair_css_class": null}