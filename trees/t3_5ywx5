{"controversiality": 0, "retrieved_on": 1427425704, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02arr0", "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 22, "score_hidden": false, "body": "Context is a bitch, ain't it.", "author": "logan_capaldo", "created_utc": "1193141770", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 22, "parent_id": "t3_5ywx5", "id": "c02arr0", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -2, "author": "HotBBQ", "created_utc": "1193144301", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c02as3i", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425699, "score": 3, "score_hidden": false, "body": "I agree.   The specifics of C++ and game programming aside though, it's a good general point to differentiate between optimizations that: 'have manageable side-affects' and those that convulute the code.   It only takes a little judgement and experience to tell the difference between the two but perhaps that's exactly what new grads lack :-)", "author": "stkni", "created_utc": "1193145738", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 3, "parent_id": "t1_c02aryu", "id": "c02as3i", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 23, "author": "cia_plant", "created_utc": "1193145972", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193147772", "ups": 3, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425696, "score": 3, "body": "Yes, yes and yes.", "id": "c02ascm", "author": "MarshallBanana", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02ascm", "parent_id": "t1_c02as4p", "score_hidden": false, "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 13, "author": "syntax", "created_utc": "1193152777", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c02atrx", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425678, "score": 8, "body": "you're right, I misspoke.\n\nI didn't mean that there weren't any possible memory allocation optimizations in other languages - only that the range of possible optimizations is more limited.\n\nI also misspoke when I said that \"other languages\" are unable to compete with C. What I meant was high-level, garbage-collected and/or dynamically-typed languages are not able to achieve the same results as optimized C. Forth, Fortran, D, etc., can usually get close to C and in some cases can do better.", "author": "cia_plant", "created_utc": "1193157973", "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "ups": 8, "parent_id": "t1_c02at0v", "score_hidden": false, "id": "c02atrx"}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1193205511", "name": "t1_c02azh5", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425604, "score": 1, "score_hidden": false, "id": "c02azh5", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02at0v", "body": "Object pooling rules.\n\nSo whenever memory is scarce, Java has to *traverse all memory* anyway, but it doesn't free anything.  Instead, you have to implement *your own MM*, too.  Life is great.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02azs0", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425600, "score": 1, "score_hidden": false, "body": " &gt; This is due partly to things like the alising problem, and partly because it has much better support for vectorisng calculations.\n\nGoogling found me [\"Will C++ be faster than Fortran?\"](http://ubiety.uwaterloo.ca/~tveldhui/papers/iscope97/index.html) from Bizarro 1998. Comments anyone? (I take it the answer was \"No\"?) ", "author": "leoc", "created_utc": "1193212775", "distinguished": null, "edited": true, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02at0v", "id": "c02azs0", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 13, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425687, "body": "&gt; Most other languages use garbage collection, so it would be impossible to optimize memory allocation.\n\nThat's just plain false.\n\nWhere to begin:\n\nStrictness annotations in Haskell?\nObject pooling in Java?\nOr replacing GC strategies in Java?\n\nThat's three optimisations applied by a programmer, to a HLL with a GC.  Sure, they are rather different - but the are still the same sort of thing.\n\n&gt; These are some of the reasons why other languages are unable to achieve the same speed as optimized C.\n\nFortran kicks your optimised C in the nads, when it comes to number crunching.  By, in some cases, orders of magnitude.\n\nThis is due partly to things like the alising problem, and partly because it has much better support for vectorisng calculations.  ", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02at0v", "parent_id": "t1_c02as4p", "id": "c02at0v", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": -3, "author": "OMouse", "created_utc": "1193162695", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 8, "author": "MarshallBanana", "created_utc": "1193165315", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02azh7", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425604, "score": 2, "score_hidden": false, "id": "c02azh7", "author": "[deleted]", "created_utc": "1193205592", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 2, "parent_id": "t1_c02aurh", "body": "I think normal C parameter passing looks very slow (at least for small functions), but then most people only write huge functions (more than five lines) and probably x86 is already very optimized to stack accesses, pushes, and pops.", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02aurh", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 8, "link_id": "t3_5ywx5", "retrieved_on": 1427425665, "id": "c02aurh", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02auek", "body": "With modern compilers, it often takes significant effort to do better than the compiler when hand-writing assembly, thanks to function timing being much, much more complex. That is not to say it is impossible, but it is very seldom worth the extreme losses in readability and development speed.", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427425649, "subreddit_id": "t5_2fwo", "archived": true, "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 1, "id": "c02aw04", "author": "bluGill", "created_utc": "1193174380", "distinguished": null, "edited": false, "body": "As MarshallBananna points out, it is hard to do better than the compiler.   Making things worse, in the few cases where it is worth getting that last .02%, you have to write 10 different versions, because there are so many differetn CPUs (10 assumes you just stick to popular x86 - AMD and Intel so you jsut have to worry about a few CPUs and cache sizes.    Some poeople may wish to add in VIA x86, x86-64, ARM, PPC, sparc, and perhaps a few more - most with several different processors in the family that need to be treated differently)\r\n\r\nIf you don't, you will get that .02% gain on your Intel Centrino, but be 5% slower on AMD athalon.", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02aw04", "parent_id": "t1_c02auek", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": -3, "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425669, "id": "c02auek", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02auek", "parent_id": "t1_c02as4p", "body": "&gt;These are some of the reasons why other languages are unable to achieve the same speed as optimized C.\n\nWhy not just do everything Assembly then if you want speed?", "author_flair_css_class": null}], "subreddit": "programming", "ups": 23, "name": "t1_c02as4p", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425699, "score_hidden": false, "body": "Not moot so much as impossible.\n\nMost other languages use garbage collection, so it would be impossible to optimize memory allocation.\n\nIf you were using a dynamically typed language, it would likewise be impossible to avoid the overhead of runtime type inspection.\n\nThese are some of the reasons why other languages are unable to achieve the same speed as optimized C.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02aryu", "id": "c02as4p", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 5, "author": "schwarzedrache", "created_utc": "1193146416", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "[deleted]", "created_utc": "1193147398", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "schwarzedrache", "created_utc": "1193148788", "children": [{"controversiality": 0, "retrieved_on": 1427425690, "subreddit_id": "t5_2fwo", "created_utc": "1193151319", "name": "t1_c02asst", "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 2, "score_hidden": false, "id": "c02asst", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 2, "parent_id": "t1_c02asgt", "body": "&gt;The main point was you should never rely on a HLL to program for you.\n\nVery true, although there's nothing inherently wrong with HLLs.\n\nIt's really a matter of learning how to program -  how to properly abstract out complex problems, combined with an understanding of how the machine you're working on works, and an understanding of how to write efficient algorithms.\n\nAn absence of any of those leads to poor code, and brittle programs.\n\nI will say that there's been quite the influx of people not learning enough before trying to implement something very complicated, and that that is partly due to the recent rise in popularity of HLLs.\n\n&gt;No love for LWJGL?\n\nI hadn't heard of it (and I'm not primarily a game programmer), but that looks pretty sexy - I might just brush up on my Java again and check it out.\n\n", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "nobodysbusiness", "created_utc": "1193156893", "children": [{"controversiality": 0, "retrieved_on": 1427425676, "subreddit_id": "t5_2fwo", "archived": true, "ups": 3, "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 3, "body": "Its a dangerous business, letting HLLs abstract the messy details away from you. I'm not saying don't do it, im saying **know the implications of each line of code you write.**\r\n\r\nString1 += String2 + String3 + String4;\r\n", "author": "schwarzedrache", "created_utc": "1193158462", "distinguished": null, "edited": false, "id": "c02atur", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02atur", "parent_id": "t1_c02atme", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02atme", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 2, "link_id": "t3_5ywx5", "retrieved_on": 1427425680, "id": "c02atme", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02asgt", "body": "&gt; The main point was you should never rely on a HLL to program for you.\n\nBut isn't C++ a high-level language, compared to machine code? I think that you actually should let a HLL program for you, if performance constraints will allow you to get away with it. The more work that the computer does for you, the better.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 2, "name": "t1_c02asgt", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425695, "score_hidden": false, "body": "No love for LWJGL? Before the hordes attack me, i've been getting good results on my 2D CIV clone. \r\n\r\nNo you are correct, that wasn't my main point- I just chose some java examples because thats what I have most experience in. \r\n\r\nThe main point was you should never rely on a HLL to program **for** you.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02asb2", "id": "c02asgt", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193152670", "ups": 3, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425687, "score": 3, "body": "I didn't have any particular language in mind, but it is *possible* to write a 3D game in Java.  I make no claims on performance, though.", "id": "c02at08", "author": "HotBBQ", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02at08", "parent_id": "t1_c02asb2", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425697, "body": "I know it's not your main point, but I really doubt HotBBQ was talking about Java when writing \"replaced with another language\"", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02asb2", "parent_id": "t1_c02as6p", "id": "c02asb2", "author_flair_css_class": null}], "subreddit": "programming", "ups": 5, "name": "t1_c02as6p", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425698, "score_hidden": false, "body": "If you don't understand the difference between StringBuilder, StringBuffer and String, you can easily write terrible code. \r\n\r\nIf you use the wrong data structure to store your information- linked list to store phone numbers that you need to look up later for instance, you're going to really be in a world of hurt. \r\n\r\nHigh(er) level programming languages are great and wonderful and we should use them as much as possible- but CS101 should probably be an architecture, data structures or an assembly language course, rather than 'How to program OO'. ", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02aryu", "id": "c02as6p", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 12, "author": "onmytoes", "created_utc": "1193147744", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193167897", "ups": 3, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425659, "score": 3, "score_hidden": false, "body": "Write microcode much?", "author": "ccshan", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02av68", "parent_id": "t1_c02ascg", "id": "c02av68", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02ascg", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 12, "link_id": "t3_5ywx5", "retrieved_on": 1427425696, "body": "Sure, C and C++ have their quirks, but they *do* let you work in a way that's only gently insulated from the underlying hardware if you so choose.  For performance oriented code, that's a big deal.  Putting a thick layer between you and the hardware--as is the case with Python, Haskell, Ruby, Erlang--removes some superficial problems and replaces them with a giant, impenetrable wall.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02aryu", "id": "c02ascg", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1193162062", "name": "t1_c02aubu", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425670, "score": 0, "score_hidden": false, "body": "Yeah, every single person in the game industry is an idiot for using C(++) in virtually every single game ever made. We all know they're just waiting for a good lisp dialect on for the 360.\n\n", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 0, "parent_id": "t1_c02aryu", "id": "c02aubu", "author_flair_css_class": null}], "subreddit": "programming", "ups": -2, "name": "t1_c02aryu", "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425701, "score_hidden": false, "id": "c02aryu", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5ywx5", "body": "A lot of these optimizations would be moot if C or C++ were replaced with another language.", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 11, "author": "pTymN", "created_utc": "1193145176", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 11, "author": "psykotic", "created_utc": "1193148519", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 4, "author": "xzxzzx", "created_utc": "1193152083", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "chollida1", "created_utc": "1193152335", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "xzxzzx", "created_utc": "1193152489", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 8, "author": "pkhuong", "created_utc": "1193155374", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 11, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425680, "score": 11, "id": "c02atjp", "author": "[deleted]", "created_utc": "1193156311", "distinguished": null, "edited": false, "body": "[EASTL](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html)\n", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02atjp", "parent_id": "t1_c02ater", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "archived": true, "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425680, "score": 1, "body": "Yes! Thank you.", "author": "xzxzzx", "created_utc": "1193156881", "distinguished": null, "edited": false, "id": "c02atmb", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02atmb", "parent_id": "t1_c02ater", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02atyc", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425675, "score": 5, "score_hidden": false, "body": " They unfortunately didn't release any code, and insiders tell me it's exceedingly unlikely to ever happen due to internal politics.\n\nSomeone should really implement something based on that paper and release it under a BSD-like license; it's pretty damn close to a complete specification. Hint, hint! :)", "author": "psykotic", "created_utc": "1193159223", "distinguished": null, "edited": true, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 5, "parent_id": "t1_c02ater", "id": "c02atyc", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 8, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425682, "body": "It was EA Games. They had a really interesting section on their design of allocators.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02ater", "parent_id": "t1_c02asz6", "id": "c02ater", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c02asz6", "controversiality": 0, "author_flair_text": null, "ups": 3, "link_id": "t3_5ywx5", "retrieved_on": 1427425688, "body": "No, it was something intentionally released. I can't seem to find it, though, so apparently it wasn't Epic.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02asye", "id": "c02asz6", "author_flair_css_class": null}], "subreddit": "programming", "ups": 3, "name": "t1_c02asye", "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425688, "score_hidden": false, "id": "c02asye", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02asww", "body": "I think it was Valve when their code base was accidentally exposed to the world.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 4, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425689, "body": "Hmm. I remember *something* like that getting released to some fanfare at least a couple years back, and I'm pretty sure it was from Epic. Time to excercise my Google-fu.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02asww", "parent_id": "t1_c02asfx", "id": "c02asww", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 11, "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425695, "id": "c02asfx", "author_flair_text": null, "distinguished": null, "edited": true, "name": "t1_c02asfx", "parent_id": "t1_c02as1i", "body": "I'm quite sure Epic never did that. (I worked there for several years, and they don't use STL in their main code base at all, only sporadically in a few external tools.) But I think all the commonly used STL implementations, even the crappy one that ships with MSVC, have a #define flag that lets you turn off exceptions.", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 5, "author": "[deleted]", "created_utc": "1193154523", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 11, "author": "onmytoes", "created_utc": "1193158457", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "nexus2112", "created_utc": "1193178905", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "[deleted]", "created_utc": "1193205333", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "[deleted]", "created_utc": "1193220099", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "[deleted]", "created_utc": "1193245223", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "[deleted]", "created_utc": "1193299763", "children": [{"controversiality": 0, "retrieved_on": 1427425398, "subreddit_id": "t5_2fwo", "author_flair_text": null, "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 1, "score_hidden": false, "body": "Actually, the compiler *can not know* where an exception will be caught.  That's the whole point: dynamic control (i.e., not statically predictable) flow across function boundaries.", "author": "[deleted]", "created_utc": "1193328792", "distinguished": null, "edited": false, "archived": true, "id": "c02b9vm", "subreddit": "programming", "ups": 1, "parent_id": "t1_c02b7hf", "name": "t1_c02b9vm", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "score_hidden": false, "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425429, "body": "Well, that's why exceptions are supposed to generate a lot more (asm) code bloat. When you write a 'throw new exception ()' in your code, the compiler is able to know exactly where that exception will be caught, and thus knows what variables to cleanup, etc etc.\r\n\r\nThis has to be done for every throw statement. Thus a lot more code bloat. But imho, a lot more readable code.", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02b7hf", "parent_id": "t1_c02b28l", "id": "c02b7hf", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425568, "id": "c02b28l", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02b28l", "parent_id": "t1_c02b037", "body": "That's interesting...  Sounds a bit like the multi-return function call (there was a paper somewhere...).", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02b037", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_5ywx5", "retrieved_on": 1427425596, "body": "If you're saying that when using exceptions, the compiler probably still generates \"if (error) { cleanup; return; }\" code, you're wrong.\r\n\r\nThe compiler generates a GOTO statement when an exception is thrown -- if no exception is thrown, no GOTO statement was called, and no checking needs to be done.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02azgs", "id": "c02b037", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425604, "body": "But the generated code probably still contains *just that code*, because on every stack level, all objects have to be destroyed first, until you catch the exception.\n\nSo the compiler is probably just \"returning\" the exception anyway, because throwing it is not really worth it, with all those quasi-finally blocks around in C++.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02azgs", "parent_id": "t1_c02awf0", "id": "c02azgs", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02awf0", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_5ywx5", "retrieved_on": 1427425643, "body": "Manual error propagation (aka \"not using exceptions\") also incurs overhead--all the extra \"if (error) { cleanup; return; }\" code.\n\nThe amount and type of exception-related overhead in a non-throwing code path may also depend on how a particular platform implements exceptions.\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02atuo", "id": "c02awf0", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 11, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425677, "body": "From a basic point of view, exceptions don't slow down code until an exception is thrown.\n\nIn reality, there are optimizations that cannot be done with code that throws exceptions.  Exceptions also increase executable size, because of the tables necessary to support them. ", "archived": true, "distinguished": null, "edited": true, "name": "t1_c02atuo", "parent_id": "t1_c02ata6", "id": "c02atuo", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193209867", "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425601, "score": 1, "body": "&gt; c++ exceptions don't slow performance down unless an actual exception is thrown.\n\nThat depends on your architecture and calling contentions in particular.  IIRC x86 is pretty bad, as usual because there's so much history and variations that predate common use of exceptions.", "author": "rabidcow", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02azny", "parent_id": "t1_c02ata6", "score_hidden": false, "id": "c02azny"}], "subreddit_id": "t5_2fwo", "ups": 5, "name": "t1_c02ata6", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425684, "score_hidden": false, "body": "I don't know -- the way I understood it (and talked about it with several experts), c++ exceptions don't slow performance down unless an actual exception is thrown. Heck, it even is supposed to be faster than C-style function return checking because you don't have to check for any return values (and yes, i know, this is micro-optimization not worth the trouble).\r\n\r\nA rule of thumb is to only throw an exception if the scenario really is exceptional. For example, when parsing a file, don't throw an exception when the end of the file has been reached -- this is a fairly common use case. However, when a parse error occurs, it's safe to throw an exception since that should not occur. \r\n\r\nThen again, my opinion on all this is that optimization stinks (to a certain degree), and scalability is a lot more important.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02as1i", "id": "c02ata6", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02as1i", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 11, "link_id": "t3_5ywx5", "retrieved_on": 1427425700, "body": "Pretty slick. He didn't mention it, but C++ exceptions are also avoided in the game industry. I think that's why Epic released a version of STL sans exceptions.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5ywx5", "id": "c02as1i", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 8, "author": "gbacon", "created_utc": "1193146584", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 9, "author": "xzxzzx", "created_utc": "1193151170", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 4, "author": "MarshallBanana", "created_utc": "1193164988", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": -1, "author": "gbacon", "created_utc": "1193166835", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 11, "author": "MarshallBanana", "created_utc": "1193170284", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193233967", "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425585, "score": 1, "body": "\"Just this once, *but that's all I'll do!*\" Sounds nice in theory.\n\nLook, I'm not advocating promiscuous use of `dynamic_cast`. The design smell in question is the \"need\" to know an object's implementation type. That almost always indicates a mistake in design.", "id": "c02b0xz", "author": "gbacon", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02b0xz", "parent_id": "t1_c02avhe", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c02avhe", "controversiality": 0, "author_flair_text": null, "ups": 11, "link_id": "t3_5ywx5", "retrieved_on": 1427425655, "body": "Because you can put in a single little hack that speeds up your code significantly while still using all the other stuff? This isn't all that hard to figure out.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02auzr", "id": "c02avhe", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02auzr", "score_hidden": false, "controversiality": 0, "archived": true, "ups": -1, "link_id": "t3_5ywx5", "retrieved_on": 1427425662, "id": "c02auzr", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02aupj", "body": "What's the point of programming in C++ if you're going to reconjure the old C hacks at OO and reinvite the concomitant maintenance headaches?", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "xzxzzx", "created_utc": "1193171655", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "nexus2112", "created_utc": "1193179728", "children": [{"controversiality": 0, "retrieved_on": 1427425634, "subreddit_id": "t5_2fwo", "created_utc": "1193186153", "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 1, "body": "I don't actually see why this optimization would be significantly harder if you did it later, when you found that dynamic\\_casts were slow. But to be honest, I don't do all that much C++.", "author": "xzxzzx", "archived": true, "distinguished": null, "edited": false, "id": "c02ax55", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02ax55", "parent_id": "t1_c02awj4", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02awj4", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5ywx5", "retrieved_on": 1427425642, "body": "He's specifically talking about optimizations that need to be done early.  Perhaps \"mature\" is meant to suggest that experience is needed in order to tell the difference between this kind of optimization and premature optimization.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02avoc", "id": "c02awj4", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "MarshallBanana", "created_utc": "1193182110", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "xzxzzx", "created_utc": "1193186086", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "MarshallBanana", "created_utc": "1193222694", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1193232232", "name": "t1_c02b0qi", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425587, "score": 1, "score_hidden": false, "body": "It does imply that, but most of the examples add only a small amount or no design smell at all.\r\n\r\nFor example, asynchronous physics/UI does not necessarily negatively impact the design -- indeed, I would imagine that it might help decouple the software while actually improving perceived performance. Win/win, as it were.\r\n\r\nAdding a type member, on the other hand, is *going* to introduce a design smell (and almost certainly bugs!) everywhere that object's type is important, and if it's that performance-critical, then ... well, you do it anyway. But resist it! ;)", "author": "xzxzzx", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02b06p", "id": "c02b0qi", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02b06p", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5ywx5", "retrieved_on": 1427425594, "id": "c02b06p", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02ax4t", "body": "\"Without unmanagable side effects\" sort of implies \"with managable side effects\".", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "gbacon", "created_utc": "1193233651", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "xzxzzx", "created_utc": "1193245567", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "gbacon", "created_utc": "1193251824", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193257301", "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425546, "score": 1, "body": "[deleted]", "author": "[deleted]", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02b3x5", "parent_id": "t1_c02b35u", "score_hidden": false, "id": "c02b3x5"}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "xzxzzx", "created_utc": "1193257409", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425546, "score": 1, "id": "c02b3y6", "author": "xzxzzx", "created_utc": "1193257476", "distinguished": null, "edited": false, "body": "The edit button seems to be broken right now. How annoying.", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02b3y6", "parent_id": "t1_c02b3xt", "score_hidden": false, "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "gbacon", "created_utc": "1193258545", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "xzxzzx", "created_utc": "1193259971", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "gbacon", "created_utc": "1193261627", "children": [{"controversiality": 0, "retrieved_on": 1427425536, "subreddit_id": "t5_2fwo", "created_utc": "1193263522", "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 1, "id": "c02b4ov", "author": "xzxzzx", "archived": true, "distinguished": null, "edited": false, "body": "I agree completely. Algorithmic improvements sometimes pale in comparison to second-order effects, like, for example, cache misses.", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02b4ov", "parent_id": "t1_c02b4h2", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02b4h2", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5ywx5", "retrieved_on": 1427425539, "id": "c02b4h2", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02b49y", "body": "Sorry that I wasn't clear, but I was addressing the more general issue.\n\nIn other words, it's almost always better to prefer algorithmic improvements over micro-optimizations, but we shouldn't be tempted to believe that the former is a free lunch.", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02b49y", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5ywx5", "retrieved_on": 1427425541, "body": "Right, but you were responding to an example with 100,000 items with that.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02b43b", "id": "c02b49y", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02b43b", "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425544, "score_hidden": false, "id": "c02b43b", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02b3xt", "body": "&gt; n would have to be awfully big if you would think that for 100,000 items, O(n^2) is going to do better than O(n log n).\n\nPike explicitly qualified his statement: \"Fancy algorithms are slow **when *n* is small**, and n is usually small.\"", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "gbacon", "created_utc": "1193258708", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "xzxzzx", "created_utc": "1193260489", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "gbacon", "created_utc": "1193262227", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193263895", "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425535, "score": 1, "id": "c02b4qg", "author": "xzxzzx", "archived": true, "distinguished": null, "edited": false, "body": "Ok, yes, he did say that also, but I meant that that is not what he said when he said:\r\n\r\n&gt; If you make an optimization and don't measure to confirm the performance increase, all you know for certain is that you've made your code harder to read.\r\n\r\nI don't disagree that profilers are *essential*, or that measuring afterwards is a good idea, but I disagree strongly with generally saying (paraphrasing) \"*you can't know if your optimizations helped without measuring*\", as that's just bunk, and *also*, I don't agree that optimization necessarily makes code harder to read.\r\n\r\nWith 4GL languages, and smarter compilers, more optimized code is *very often easier to read*. List comprehensions vs. for loops in Python are a very good example of this -- in many cases, they're faster and easier to read.", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02b4qg", "parent_id": "t1_c02b4js", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02b4js", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5ywx5", "retrieved_on": 1427425538, "body": "[Then what's all the talk about using profilers to find the problem spots?](http://martinfowler.com/ieeeSoftware/yetOptimization.pdf)\n\n&gt; Optimizing an existing program follows a specific set of steps. First, you need a profiler -- a program that can analyze how much time your program spends in its various parts. Software performance has an 80/20 rule: 80 percent of the program's time is spent on about 20 percent of the code. Trying to optimize performance in the 80 percent of code is futile, so the first order of business is to find that 20 percent of code. Trying to deduce where the program will spend its time is also futile. I know plenty of experienced programmers who always get this wrong. You have to use a profiler.\n&gt;\n&gt; To give the profiler something to chew on, perform some kind of automated run that reasonably simulates the program under its usual conditions. An automated test suite is a good starting point, but make sure you simulate the actual conditions. My colleague Dave Rice has a rule: \"Never optimize a multiuser system with single-user tests.\" Experience has taught us that a multiuser database system has very different bottlenecks than a single user system -- often focused around transaction interactions. The wrong set of tests can easily lead you to the wrong 20 percent of code.\n&gt;\n&gt; Once you've found your bottlenecks, you have two choices: speed up the slow things or do the slow things less often. In either case, you must change the software.  This is where having a well-designed piece of software really helps. It's much easier to optimize cohesive, loosely coupled modules.  Breaking down a system into many small pieces lets you narrow down the bottlenecks. Having a good automated test suite makes it easier to spot bugs that might slip in during optimization.\n&gt;\n&gt; It's worth knowing about various optimization tricks, many of which are particular to specific languages and environments. The most important thing to remember is that the tricks are not guaranteed to work -- as the saying goes, \"Measure twice, cut once.\" Unlike a tailor, however, you measure before and after you've applied the optimization. Only then do you know if it's had any effect. It's revealing how often an optimization has little -- or even a negative -- effect. If you make an optimization and don't measure to confirm the performance increase, all you know for certain is that you've made your code harder to read.\n&gt;\n&gt; This double measurement is all the more important these days. With optimizing compilers and smart virtual machines, many of the standard optimizing techniques are not just ineffective but also counterintuitive.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02b4ca", "id": "c02b4js", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425541, "id": "c02b4ca", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02b4ca", "parent_id": "t1_c02b43x", "body": "No, I'm using a trivial case as an example.\r\n\r\nIn a complex piece of software, *of course* you need a profiler to *find* the performance problems, but that's *not* what Fowler said.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02b43x", "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425544, "score_hidden": false, "body": "You're talking about trivial cases.\n\nIf in the context of real-world, complex software we can rely on our intuition for determining where hotspots and bottlenecks will be, then why do we need profilers?", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02b3xt", "id": "c02b43x", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "gbacon", "created_utc": "1193258881", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "xzxzzx", "created_utc": "1193260515", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "gbacon", "created_utc": "1193261427", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193263320", "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425536, "score": 1, "body": " But that's simply not true.\r\n\r\nCase in point, I've spent most of the last month optimizing the hell out of another programmer's application, and been getting 5-10X speedups as a matter of course.\r\n\r\nI'm not talking about trivial changes. In one particular case, I rewrote 1,000 lines of code -- and I *knew* it would be significantly faster. And it was. With caching effects, it was 150X faster. And it was close to the way I would have written it in the first place.\r\n\r\nWere there cases where I didn't know if my change was going to improve speed? Sure. Tons of them. But there were also cases where I knew exactly what was going on, and knew exactly how to fix it. In a large, complex application, written in a 4GL.\r\n\r\nDid I profile again after I fixed stuff which I knew to be fixed? Of course I did! But only to find where the new slowest points were.\r\n\r\nFowler uses faulty reasoning. He thinks that because making architectural decisions (or whatever) with performance in mind does not uniformly produce fast code, that those decisions were wasted. This is *not* necessarily the case, and in fact is exactly the point of the linked article that we're talking about -- that some optimizations *have to* be done early or will take an inordinate amount of effort to do.\r\n\r\nPerhaps I'm an exceptional case, because I have a very good grasp of the approximate cost of doing just about everything -- all the way from how language features work to how long something takes to hit the disk, to how Windows does paging, to how expensive a CPU cache miss is, etc, etc. But I would expect most programmers would at least have a vague concept of all of that. ", "author": "xzxzzx", "archived": true, "distinguished": null, "edited": true, "id": "c02b4o4", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02b4o4", "parent_id": "t1_c02b4g6", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425539, "body": "Except in trivial cases, you don't know -- although you might have a hunch -- that you've improved performance until you've measured.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02b4g6", "parent_id": "t1_c02b4cg", "id": "c02b4g6", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02b4cg", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425541, "score_hidden": false, "body": "What?", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02b44r", "id": "c02b4cg", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "name": "t1_c02b44r", "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5ywx5", "retrieved_on": 1427425543, "body": "&gt; Fowler's also right when compared with the majority of optimization cases. His blanket statement is what I have a problem with.\n\nFowler's blanket statement is a special case of the more general \"the plural of anecdote is not data.\"", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02b3xt", "id": "c02b44r", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425546, "body": "n would have to be awfully big if you would think that for 100,000 items, O(n^2) is going to do better than O(n log n).\r\n\r\nOk, I read the article Fowler's quote came from. Fowler seemed to be talking about any kind of optimizations at all -- and in fact, seemed to be disagreeing with this particular article. Fowler is wrong. You can, in some cases, tell if your code is going to go faster by making both architectural- and micro-optimizations.\r\n\r\nLet me give you an example of the latter. You're programming in C++, with your custom \"Iterator\" class, and you do this:\r\n\r\n    for(Iterator i; !i.IsDone(); i++) \r\n      { // Stuff happens here. }\r\n\r\nYou profile the code, and find that most of the time is being spent in the postfix of your iterator. In 100% of cases (presuming that post-increment and pre-increment is implemented sanely), this will be faster:\r\n\r\n    for(Iterator i; !i.IsDone(); ++i) \r\n      { // Stuff happens here. }\r\n\r\nThe reasons are obvious -- the language has to do less copying, doesn't have to allocate and deallocate memory all the time (even if this gets optimized mostly away, it still has some cost).\r\n\r\nYou may not be able to say *how much* faster, or if that's fast enough, no. But you can say that it is faster, and indeed, no less readable.\r\n\r\nYou can do similar and even more predictable things in assembler, too. In general, if you remove all branches, shrink the code, run in fewer cycles, and access memory in the same order (I've seen code that does all this!), you can confidently state that you've sped up your code, because you made no trade-offs -- you leveraged the hardware, or eliminated useless actions.\r\n\r\nOn the flipside, Fowler is probably right if you're talking about Java, which was his only relatively concrete example, as the VM provides an amazing disconnect between the code and the hardware, and as of recent VMs, will do wildly unpredictable things like recompiling a hotspot to optimize branches. Ironically, this actually prevents you from easily measuring performance. ;)\r\n\r\nFowler's also right when compared with the majority of optimization cases. His blanket statement is what I have a problem with.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02b3xt", "parent_id": "t1_c02b35u", "id": "c02b3xt", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02b35u", "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425556, "score_hidden": false, "id": "c02b35u", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02b2a0", "body": "I believe Fowler is talking about micro-optimizations.\n\nChoosing an algorithm with better complexity isn't a free lunch either. [Consider Rob Pike](http://www.lysator.liu.se/c/pikestyle.html):\n\n&gt; **Rule 3.** Fancy algorithms are slow when *n* is small, and *n* is usually small.  Fancy algorithms have big constants. Until you know that *n* is frequently going to be big, don't get fancy.  (Even if *n* does get big, use Rule 2 first.) For example, binary trees are always faster than splay trees for workaday problems.", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c02b2a0", "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425567, "score_hidden": false, "id": "c02b2a0", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c02b0wm", "body": "  I don't think I get your point.\r\n\r\nLarger performance gains almost always come from optimizing the structure and algorithms involved. You don't need a profiler to tell you that if you're bubble sorting 100,000 randomized items, it's going to take a long time.\r\n\r\nAnd Martin Fowler is wrong (or taken out of context). There are many optimizations which are *always* faster, and many which do not make your code any harder to read. It's difficult to come up with a trivial example in a language like C, because the compiler does most of those sort of optimizations for you, but they do exist.  ", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c02b0wm", "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425585, "score_hidden": false, "id": "c02b0wm", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02ax4t", "body": "Martin Fowler: \"If you make an optimization and don't measure to confirm the performance increase, all you know for certain is that you've made your code harder to read.\"\n\nNote that \"know\\[ing] in advance\" is not the same as measuring. If we could rely on our intuition, we wouldn't need profilers.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02ax4t", "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425634, "score_hidden": false, "id": "c02ax4t", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02awrv", "body": "Well, the author says:\r\n\r\n&gt; Mature optimization is any optimization done early in development that you know in advance will provide a significant performance boost without unmanageable side effects.\r\n\r\nObviously what consitutes \"unmanageable\" is totally subjective.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425639, "body": "The point of the article was that you should not worry about things like \"design smell\" to the point where you are impeding the speed of the code, if that code needs to be fast. Obviously the author knows that that is not perfectly *elegant* code, but he also knows that that is the way to *get the job done*.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02awrv", "parent_id": "t1_c02avoc", "id": "c02awrv", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02avoc", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425653, "score_hidden": false, "body": "I can't really speak for him, but it doesn't seem that way to me. The point of these \"mature\" optimizations is that they make stuff faster without breaking the design (too much).\r\n\r\nI'm not saying it's a bad optimization, really, I'm just saying using it is certainly going to introduce a design smell, just as gbacon suggested.\r\n\r\nBlindly saying \"&lt;dynamic\\_cast&gt; bad\" is about as bad as saying \"never worry about &lt;dynamic\\_cast&gt;\", that's all.\r\n\r\nEdit: Curse you, markdown!", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02aupj", "id": "c02avoc", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02aupj", "ups": 4, "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425665, "score_hidden": false, "id": "c02aupj", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02ass4", "body": "He was being downmodded for having the point fly high over his head.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 9, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425690, "body": "Not sure why you're getting downmodded.\r\n\r\nYou've certainly got a point, although keep in mind the context of a high-performance game engine.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02ass4", "parent_id": "t1_c02as7b", "id": "c02ass4", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427425671, "subreddit_id": "t5_2fwo", "created_utc": "1193161636", "ups": -1, "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": -1, "body": "Masturbating to the sheer beauty of [lisp/rails/haskell/etc] doesn't get you very far in commercial game programming.", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "id": "c02au9a", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02au9a", "parent_id": "t1_c02as7b", "score_hidden": false, "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "[deleted]", "created_utc": "1193205429", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "gbacon", "created_utc": "1193234247", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1193245877", "name": "t1_c02b2be", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425567, "score": 1, "score_hidden": false, "id": "c02b2be", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02b0yz", "body": "If the language does it intelligently, yes.  If the compiler will only insert the code for those objects that will ever be called for it.  But C++ includes *a lot* of object code as I've seen comparing C to what should be *equivalent* C++ (according to: you only pay for the features you use/need.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02b0yz", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5ywx5", "retrieved_on": 1427425584, "body": "&gt; Why? Isn't the ability to infer types dynamically a *trait* of an object? Why then shouldn't it be a normal virtual function?\n\nWhy use an object-oriented language (or even C++!) if you're going to write your own dispatch? Let the language work for you!", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02azgx", "id": "c02b0yz", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "score_hidden": false, "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425604, "id": "c02azgx", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02azgx", "parent_id": "t1_c02as7b", "body": "Why?  Isn't the ability to infer types dynamically a *trait* of an object?  Why then shouldn't it be a normal virtual function?\n\nI think it's stupid to have the compiler generate all kinds of functions for objects that aren't ever meant to be used in a dynamic context where you don't even know their type and need to know it.  This is what makes C++ object code bloated (well, one little part of it anyway).", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02as7b", "ups": 8, "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425698, "score_hidden": false, "id": "c02as7b", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5ywx5", "body": "&gt; Instead of using &lt;dynamic_cast&gt; you should first identify those classes that require some kind of run-time type inspection, consider if you really need it, and then incorporate a type member variable into the base class...\n\nHoly design smell, Batman!", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 9, "author": "Kolibri", "created_utc": "1193153410", "children": [{"controversiality": 0, "retrieved_on": 1427425676, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02atx3", "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 5, "score_hidden": false, "body": "Also note that in game development there aren't many \"2% of the code does 90% of the work\" cases where optimization is a (relatively) simple matter of profiling and tuning.\n\nIn that context this advice makes sense, but most likely if you are doing anything else you just need to figure out where your code spends all of its time and speed that up.", "author": "awj", "created_utc": "1193158939", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 5, "parent_id": "t1_c02at3p", "id": "c02atx3", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427425673, "subreddit_id": "t5_2fwo", "created_utc": "1193160795", "name": "t1_c02au5g", "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 7, "score_hidden": false, "id": "c02au5g", "author": "pl0nk", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 7, "parent_id": "t1_c02at3p", "body": "&gt; In most applications performance isn't much\n&gt; of an issue\n\nIn my experience performance is a big  issue in almost all _interesting_ applications.  However that's a small subset of the total set of apps out there, so I suppose I still agree with your statement.\n\n&gt; and bad performance is generally\n&gt; caused by a few bottlenecks\n\nI've not found this to be the case in my professional experience.  There's this dogma that you can run your app in some profiler, find this hotspot that is 90% of the time, and fix that.  Maybe that's the case if you are clueless about how your compiler works to begin with, or have a large team of inexperienced folks.  More often I find that careful small choices throughout the codebase are crucial for good performance, and substantial performance gains often take some careful measurement and consideration that crosses several layers of abstraction to find a better solution.  Just my $0.02.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c02awhm", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425642, "score": 2, "score_hidden": false, "id": "c02awhm", "author": "nexus2112", "created_utc": "1193179425", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 2, "parent_id": "t1_c02at3p", "body": "\"bad performance is generally caused by a few bottlenecks\"\n\nOh, how I wish that were true more often.  At first it often is.  But I know exactly what he's talking about.  When no single function is taking more than 1% of the execution time, the profiler suddenly seems a whole lot less useful.  This situation is common with apps that have already undergone a fair amount of profiler-guided optimization and still aren't fast enough.  At that point you're usually either approaching the limits of what the hardware will do, or some major system-level refactoring is in order.  Part of the difficulty is telling the difference.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 9, "name": "t1_c02at3p", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ywx5", "retrieved_on": 1427425687, "score_hidden": false, "body": " Note that this article only focuses on game development. An area where every little bit of performance gain counts. In most applications performance isn't much of an issue and bad performance is generally caused by a few bottlenecks.\r\n\r\nIn those cases it's important not to do premature optimization. Fixing the few bottlenecks afterwards will get you code that's maintainable and efficient *enough*. ", "archived": true, "distinguished": null, "edited": true, "parent_id": "t3_5ywx5", "id": "c02at3p", "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427425685, "subreddit_id": "t5_2fwo", "created_utc": "1193153800", "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "downs": 0, "score": 1, "body": "[deleted]", "author": "[deleted]", "archived": true, "distinguished": null, "edited": true, "id": "c02at5t", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02at5t", "parent_id": "t3_5ywx5", "score_hidden": false, "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "DannoHung", "created_utc": "1193156121", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02auq5", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425665, "score": 6, "score_hidden": false, "id": "c02auq5", "author": "MarshallBanana", "created_utc": "1193165102", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 6, "parent_id": "t1_c02atiw", "body": "None of that is about algorithms. It is about system design.\n\nAnd no, your corollary is entirely wrong. If you make it so your \"algorithms can be easily substituted\", that forces you to design for much more general cases, and prevents you from writing optimized code, and for structuring other code around the algorithms you use. This is the exact opposite of how you want to design something that needs to be truly fast.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 2, "name": "t1_c02atiw", "controversiality": 0, "archived": true, "link_id": "t3_5ywx5", "retrieved_on": 1427425681, "score_hidden": false, "id": "c02atiw", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5ywx5", "body": "Seems like most of the advice can be boiled down to: Pick a good algorithm first.\n\nNow, that's not always easy at the start, so I'd guess a corollary might be \"Make it so that your algorithms can be easily substituted\"? ", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193163260", "name": "t1_c02augy", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425669, "score": 2, "score_hidden": false, "body": "And there I thought this would be something about sexy 40 something ladies.\r\n\r\nBut then I saw the programming tag and my dreams dissapeared in a puff.", "author": "Eugi", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 2, "parent_id": "t3_5ywx5", "id": "c02augy", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193173766", "ups": 1, "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425649, "score": 1, "body": "[deleted]", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "id": "c02avyq", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02avyq", "parent_id": "t3_5ywx5", "score_hidden": false, "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02ax5k", "gilded": 0, "link_id": "t3_5ywx5", "retrieved_on": 1427425634, "score": 1, "score_hidden": false, "id": "c02ax5k", "author": "Tommah", "created_utc": "1193186289", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t3_5ywx5", "body": "This is only for matuuuure people, okay Stan?", "author_flair_css_class": null}