{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 21, "author": "gthank", "created_utc": "1192538215", "children": [{"controversiality": 0, "retrieved_on": 1427426308, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029h4w", "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 8, "score_hidden": false, "id": "c029h4w", "author": "novagenesis", "created_utc": "1192544392", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 8, "parent_id": "t1_c029gog", "body": "It's a good point.  There is a genuine problem that native functionality makes it easier to use less efficient algorithms in many cases.  It's very VERY easy to iterate and create new data using foldr or map, when there's often a faster, more efficient way to do things.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 21, "name": "t1_c029gog", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426314, "score_hidden": false, "body": "It's too bad they chose such a bad headline: I thought the post itself was actually pretty interesting. I especially liked this nugget from the judges: \"So programmers should worry less about languages and more about good old complexity.\"", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5yek3", "id": "c029gog", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -6, "author": "Gotebe", "created_utc": "1192541210", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -4, "author": "qwe1234", "created_utc": "1192541531", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 4, "author": "Gotebe", "created_utc": "1192542982", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -3, "author": "qwe1234", "created_utc": "1192544648", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 4, "author": "Gotebe", "created_utc": "1192546680", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": -5, "author": "qwe1234", "created_utc": "1192546784", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c029hjn", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426303, "score": 3, "score_hidden": false, "id": "c029hjn", "author": "Gotebe", "created_utc": "1192548645", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 3, "parent_id": "t1_c029hdb", "body": "Yes, I have.\n\nI think age != mainstream-ness, but I didn't even try to speak about time dimension of it.\n\nBut I see your point, in that age is rather telling for the future, as you harshly advocate.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": -5, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426305, "id": "c029hdb", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029hdb", "parent_id": "t1_c029hcv", "body": "did you read my comment?\n\nc++, java, .net and php (among others) are all much, much younger than most fp languages.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c029kf6", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426265, "score": 0, "score_hidden": false, "id": "c029kf6", "author": "grauenwolf", "created_utc": "1192573932", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 0, "parent_id": "t1_c029hcv", "body": "Keep in mind that the .NET langauges are heavily embracing functional programming. ", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 4, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426305, "id": "c029hcv", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029hcv", "parent_id": "t1_c029h5p", "body": "Probably depends on what one considers mainstream. To me, mainstream is C/++, Java platform, .NET platform, Perl, PHP, SQL dialects, *maybe* Python. By that measure, *anything* FP is way too far from these in importance.", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426303, "subreddit_id": "t5_2fwo", "created_utc": "1192547923", "ups": 1, "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 1, "id": "c029hh4", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "body": "[deleted]", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029hh4", "parent_id": "t1_c029h5p", "score_hidden": false, "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 10, "author": "[deleted]", "created_utc": "1192554017", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029moc", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426237, "score": 0, "score_hidden": false, "id": "c029moc", "author": "qwe1234", "created_utc": "1192608315", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 0, "parent_id": "t1_c029i5p", "body": "the willingness to do *anything* (especially bullshit like 'learning a different way of thinking') instead of sitting down and actually writing good software is pretty much the standard definition of a 'lazy programmer'.\n\n", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 10, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426295, "id": "c029i5p", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029i5p", "parent_id": "t1_c029h5p", "body": "Lazy programmers?! If I was lazy I'd keep using the imperative/OOP languages I already know. I have to use a completely different way of thinking, and often think more than I code, while using Haskell, Lisp, F#, etc.\n\nJust because a language is expressive, doesn't make one lazy to use it.\n\n[Edit: spelling]", "author_flair_css_class": null}], "subreddit": "programming", "ups": -3, "name": "t1_c029h5p", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426308, "score_hidden": false, "body": "it has hit 'mainstream' several times in the past 40 years, each time passing into disuse.\n\nso far the track record says that it's a fad that caters to lazy (in a bad sense of the word) programmers.\n\nthere *are* valid points to be made w.r.t. fp methodology, but fp languages are mostly bunk.\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029h0j", "id": "c029h5p", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c029hmf", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426302, "score": 1, "score_hidden": false, "id": "c029hmf", "author": "[deleted]", "created_utc": "1192549365", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c029h0j", "body": "[deleted]", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 4, "score_hidden": false, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426309, "body": "I rather think something is novel until it hits mainstream. That hasn't happened, whatever FP/whatever geeks here may say. That's why I used word \"novel\".\n\nI don't care much for FP nor am I trying to defend it. It *really* isn't of use to my work needs. But I do believe FP's interesting for some tasks.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029h0j", "parent_id": "t1_c029gwa", "id": "c029h0j", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029gwa", "score_hidden": false, "controversiality": 0, "archived": true, "ups": -4, "link_id": "t3_5yek3", "retrieved_on": 1427426311, "id": "c029gwa", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029gv5", "body": " fp isn't a novel paradigm, *especially* when compared with 'generic programming' of c++ standard library fame. \n\nneither are fp languages novel. \n\nall in all, if you have to stoop to that defense, that's solid bulletproof evidence that fp and fp languages have resoundingly failed.\n ", "author_flair_css_class": null}], "subreddit": "programming", "ups": -6, "name": "t1_c029gv5", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426311, "score_hidden": false, "body": "What's to question!? It looks like it reflects state of affairs. I don't know details of the task, but suppose it's far from trivial. Can't realistically expect a +/- novel paradigm or language to get it best.\n\nBudding languages are in big numbers, which is promising, but heavy lifting went to C++, which is the reality. It's also probable that the most competent brain-force came from there, maybe influencing the result over other factors (like perceived ease of use, or \"applicability\" to the problem).\n\nAnd, if I may, please note, *not C*, but C++. ( Although I still hold that C++ *is* C ;-) ).\n\n(edit: language)", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5yek3", "id": "c029gv5", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 6, "author": "nobodysbusiness", "created_utc": "1192542621", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -3, "author": "qwe1234", "created_utc": "1192545250", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192553371", "name": "t1_c029i34", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426296, "score": -7, "score_hidden": false, "body": "I don't know the K language, but I remember seeing a code snippet of it and noting the extremely terse syntax. I'm not convinced that it would always produce shorter programs, particularly if the coder spread the code out across multiple lines to improve readability. Does K support first-class functions? What about introspection? If it doesn't, there could be some abstractions that wouldn't be possible, potentially leading to a lot of boilerplate code.", "author": "nobodysbusiness", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": -7, "parent_id": "t1_c029h7r", "id": "c029i34", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": -3, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426307, "id": "c029h7r", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029h7r", "parent_id": "t1_c029gze", "body": "dude, if 'fewer lines of code' is your goal, then the K programming language will win every time.\n\n(yes, i am making fun of you in a very cruel manner.)\n\n", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 10, "author": "foldl", "created_utc": "1192551021", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 3, "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426296, "score": 3, "id": "c029i19", "author": "nobodysbusiness", "created_utc": "1192552986", "distinguished": null, "edited": false, "body": "Those are very good points. Now that you mention it, pattern matching is something that I have been meaning to look into in more depth.", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c029i19", "parent_id": "t1_c029ht6", "score_hidden": false, "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "[deleted]", "created_utc": "1192553308", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 5, "author": "magnusjonsson", "created_utc": "1192556878", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "[deleted]", "created_utc": "1192595678", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "foldl", "created_utc": "1192800313", "children": [{"controversiality": 0, "retrieved_on": 1427425950, "subreddit_id": "t5_2fwo", "created_utc": "1192879669", "name": "t1_c02a8ql", "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 1, "score_hidden": false, "body": "[deleted]", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02a2ao", "id": "c02a8ql", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c02a2ao", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426034, "score_hidden": false, "body": "  You're not making any sense. Why is preprocessing the Python assert statement more difficult using parser combinators than using some other approach? You do realize that it's perfectly possible to manipulate the parse tree after it's been created by running your combinator parser.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c029lzg", "id": "c02a2ao", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029lzg", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5yek3", "retrieved_on": 1427426245, "body": "Since my remark caused so much disagreement, here a brief disclaimer. There is of course nothing wrong with parser combinators compared to imperative switches and actions or compared to the Go4 interpreter pattern. They are all on the same footing and just  fine when you have nothing else, your language is small ( or context dependent ) and your purpose is fixed. \n\nNow I want deal in many different ways with a language as data. Lets say I want to preprocess Pythons assert statement to make it more expressive. The code needed to transform the assert statement acting on a parse tree is just a few lines: seeking all assert statement nodes in the parse tree. Keep the content of the expressions passed into the assert statement. Pass the content into a parser node constructor that expresses a function call. Define the function. Replace the original content of the assert statement and finally send the modified tree to the bytecode compiler. On demand unparse the tree again or at least the modified assert statement parse tree fragment and display it as source code.\n\nI'd be rather pissed of when having to write a full Python parser for any kind of action I want to define or even have to deal with textual substitutions as if I had a C preprocessor. \n\nIn the end I split the problem of language processing into three distinct parts: creating a parse tree ( purpose of parser generators ). A library defining actions on parse trees in a uniform and language independent fashion. Using the library and write code for a particular action as in the example above. \n\nIn this picture the library becomes the crucial issue once the parser generator is established. And no I don't talk about XSLT or XPath specifically although they are obvious library examples for XML based languages. I'd rather assume that XML based languages became so popular because of the lack of good libraries for postprocessing parse trees. IMO this is the way to go not the regression into handcrafted parsers, or juggling with flexible syntax a la Ruby or writing source code in s-expr style.\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029ihy", "id": "c029lzg", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029ihy", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 5, "link_id": "t3_5yek3", "retrieved_on": 1427426290, "id": "c029ihy", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029i2n", "body": "Do you have a concrete example where parser combinators   are a pain in the ass compared to using parser generators?", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426283, "subreddit_id": "t5_2fwo", "created_utc": "1192561801", "ups": 6, "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 6, "id": "c029j37", "author": "augustss", "archived": true, "distinguished": null, "edited": false, "body": "I find parser generators to be a pain.  The lack of high level abstractions makes using them really tedious.", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029j37", "parent_id": "t1_c029i2n", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426296, "id": "c029i2n", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029i2n", "parent_id": "t1_c029ht6", "body": "I would rather claim that hand written parsers are a pain in the ass. One also does not create a regex engine for any regex one wants to match. Unless one wants to parse non CFGs ( C++ anyone? ) a parser generator shall create the parser ( or the parse table on which the parser operates ).\n\n*GHC is really good at optimizing iterations over lazy lists into loops, whereas Ruby and Python iteration can be quite slow.*\n\nBut that argument holds for any Python operation, also assignments and function calls. The rationale for scripting languages to deal with performance bottlenecks is well known. It's less than clear in languages like Haskell ( but also Java ). When the programmer designs code in an imperative fashion in Haskell or OCaml to gain maximum performance why not advising him to use just C++?", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 10, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426299, "body": "Yeah, writing a parser. Haskell has some nice efficient parser combinator libraries available. It's just about possible to write parser combinators in Python/Ruby but it's a pain in the ass and it's really, really slow.\n\nGHC is really good at optimizing iterations over lazy lists into loops, whereas Ruby and Python iteration can be quite slow.\n\nHaskell also has pattern matching, which is a pretty big win over Python in terms of conciseness and readability.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029ht6", "parent_id": "t1_c029gze", "id": "c029ht6", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 6, "name": "t1_c029gze", "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426310, "score_hidden": false, "id": "c029gze", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5yek3", "body": "I've looked into functional programming before. I used Haskell for a few months to compete in one of Al Zimmerman's programming contests. Unfortunately, I have also find myself questioning if it really does increase productivity or not. On one hand, Haskell has lazy evaluation, allowing separation of generation and selection. But isn't this also possible in languages like Python, using generators? Here's a question for more avid Haskellers: Is there something that you can do much more quickly/easily (ie. fewer lines of code) in Haskell than in a language like Python/Ruby?", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 37, "author": "damienkatz", "created_utc": "1192544480", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192545139", "ups": 6, "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426307, "score": 6, "body": "That was a clever point and a nice perspective on Erlang.  Thanks. ", "author": "hopeless_case", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029h78", "parent_id": "t1_c029h57", "score_hidden": false, "id": "c029h78"}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 12, "author": "asb", "created_utc": "1192547347", "children": [{"controversiality": 0, "retrieved_on": 1427426284, "subreddit_id": "t5_2fwo", "created_utc": "1192560971", "name": "t1_c029izr", "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 3, "score_hidden": false, "body": "See [here](http://icfpc.plt-scheme.org/icfpc2005-talk.pdf) for more detailed rationale.", "author": "muleherd", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 3, "parent_id": "t1_c029hfh", "id": "c029izr", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 12, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426304, "id": "c029hfh", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029hfh", "parent_id": "t1_c029h57", "body": " The [ICFP 2005 contest](http://icfpc.plt-scheme.org/) had a second task announced two weeks after the first one, which would require modifying the original solution. ", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "Gotebe", "created_utc": "1192548577", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 14, "author": "evgen", "created_utc": "1192552761", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "archived": true, "ups": 2, "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426231, "score": 2, "id": "c029n1d", "author": "Gotebe", "created_utc": "1192618223", "distinguished": null, "edited": false, "body": "Out of three links you put up...\n\nFirst is the ping-back on Armstrong's post I looked at. That post has one rather synthetic test (just passing messages around) which, of course is easily parallelizable and gives good speedup on SMP system. The other, which I think is more realistic, doesn't work out great. That's why I put \"you can't beat P\" in my post.\n\nSecond link is with ant colony problem, which I think is also well parallelizable (am I wrong?), so of course it will run close to twice as fast with Erlang/SMP than with classic ONE, which only has one thread and won't use more than 1/no of cores of processing power.\n\nThe third link... Well, it actually measures \"speed/scheduler no\" ratio and I think results are what is to be expected. The test (big.erl) again, is just passing messages around, so it's parallel in itself. It should just max out all cores, and that's it, really. Of course it deteriorates (decently) for anything over 4, as the test was on 4 core system.\n\n&gt;Erlang is not touted as a multi-threading language, it is touted as a concurrency language...\n\nI agree 100%. My beef is that it's often put up when \"concurrency\" is used for \"multithreading\".\n\nWRT \"closed\"... Your explanation is exactly what is the problem. Say you have beautiful piece of code that does X, and I want to use it. I think, telling me to open a socket to \"call it\" is not being serious. And if I am on the same machine, or worse yet, in the same process, it's out of line.", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029n1d", "parent_id": "t1_c029i04", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029i04", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 14, "link_id": "t3_5yek3", "retrieved_on": 1427426297, "id": "c029i04", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029hjj", "body": "   [A](http://www.franklinmint.fm/blog/archives/000792.html)  [near](http://www.bluishcoder.co.nz/2006/03/erlang-smp-benchmarks.html) [linear](http://eric_rollins.home.mindspring.com/erlangAnt.html) [speed-up](http://mult.ifario.us/articles/2006/05/11/more-on-erlang-performance-and-threading) \"doesn't look too good\"?  What exactly were you expecting? As you noted, SMP support is new to Erlang and it takes a bit of tweaking with the number of schedulers to find the sweet spot for a particular architecture, but as the Erlang developers get more experience with tuning for SMP and learning the gory guts of various systems' baroque threading policies this is bound to improve.  You still can't get around Amdahl's law, but Erlang makes it easier to get close to the limit without pushing you past the edge of insanity.\n\nErlang is not touted as a multi-threading language, it is touted as a concurrency language.  This means that it deals with multi-core and the much more common multi-node situation in a fairly transparent manner.  \n\nConnection points to Erlang systems, whatever that means, are also not as difficult as you suggest.  Few languages sling packets as well as Erlang, so the base level of interaction is to use a TCP/IP socket.  A port driver is pretty trivial to set up in Erlang but this ease comes at a speed cost.  If you are willing to trade reliability for speed then a linked-in driver is the way to go, but this is non-trivial unless you dive into one of the driver toolkits (which is only a small step easier than \"non-trivial\"...)  Fast FFI is definitely something Erlang needs, but to declare Erlang systems \"closed\" is quite inaccurate.   ", "author_flair_css_class": null}], "subreddit": "programming", "ups": 3, "name": "t1_c029hjj", "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426303, "score_hidden": false, "id": "c029hjj", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029h57", "body": "Good point.\n\nOTOH, \"taking the concept to the end\" isn't great. If anything, languages that dilute any concept (like C++ or Java) are *more* successful, exactly because any given concept does not make a great all rounder in a language.\n\nIn fact, Erlang is a good example, I think. SMP support is rather new in it, despite Erlang being (wrongly, even) tauted as multithreading language. And on top of that, [SMP tests on Erlang I saw](http://www.erlang-stuff.net/wordpress/?p=14) don't look too great to me. Not bad, but not great, either.\n\nAnd that's not Erlang's efficiency problem, but rather the implementation, or even the problem itself. I guess it's just too hard to beat P in Amdahl's law.\n\nAlso, chances are that Erlang \"systems\", while hopefully reliable, will stay *closed*. Who knows when, if ever, will we have easy connection points to them.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1192597850", "name": "t1_c029m4i", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426243, "score": 6, "score_hidden": false, "id": "c029m4i", "author": "berlinbrown", "archived": true, "distinguished": null, "edited": true, "author_flair_text": null, "subreddit": "programming", "ups": 6, "parent_id": "t1_c029h57", "body": "   I would also like to add; can we stop with the endless amount of pointless blog entries (especially on reddit) about \"I did X (opened a file) in Haskell\".  They don't really further the cause of demonstrating the potential of the advantages of functional programming (but these entries might be good to post to a mailing list).  Blog entries are great, but I think the excitement over Haskell 101 tutorials is a bit much.\n\nCouchDB for example is a useful tool.  Hearing about how a person converted his production rails/mysql application to a rails/couchdb (or whatever is trending these days) and how this company handled millions of requests a day might be worth hearing about.\n\nI do a lot of those boring blog entries (because I can't write technical articles), so I am no saint in this area; but I am moving past the learning phase and jumping right into writing an application.  (And no saint in posting interesting functional development articles to reddit; so I will stop with the noise).\n\nSo, I would encourage others to follow suit.   And there is already a load of useful Erlang and Haskell programs like; Couchdb, Darcs, Yaws, etc, etc. \n   ", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029h57", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 37, "link_id": "t3_5yek3", "retrieved_on": 1427426308, "id": "c029h57", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5yek3", "body": "   For contests, functional programming does not offer much, if any, advantage. Functional programming is not inherently faster, in runtime or development time, than imperative programming.\n\nBut functional code, because of lack destructive updates, does tend to be much more reliable than other styles. It's much easier to recover from edge error conditions when you don't have data structures in a half modified state. Erlang takes this concept to the logical end, and makes it possible to build extremely reliable systems.\n\nSo the thing about theses programming contests is they are completley geared to writing throw-away code. This code will not be reused or maintained, its needed only for the contest. If it has edge condition bugs or memory leaks, it probably matters not. It only has to fill the very narrow requirements of the contest, after which it's thrown away.   ", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -7, "author": "redditnoob", "created_utc": "1192548355", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": -7, "author": "Gotebe", "created_utc": "1192548917", "children": [{"controversiality": 0, "retrieved_on": 1427426301, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029hmp", "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 13, "score_hidden": false, "body": "what? no.\n\nyou're don't know what you're talking about.\n\nfp == stateless function calls. nothing more or less. 'sequentialness' has nothing to do with it. (and multi-threaded C is as 'non-sequential' as you can physically get.)\n", "author": "qwe1234", "created_utc": "1192549390", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 13, "parent_id": "t1_c029hkj", "id": "c029hmp", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 7, "author": "wozer", "created_utc": "1192555483", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c029n2c", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426231, "score": 1, "score_hidden": false, "id": "c029n2c", "author": "Gotebe", "created_utc": "1192618774", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c029ibz", "body": "&gt;On the other hand, I agree that lazy evaluation can lead to non-intuitive behaviour.\n\nYeah, that's what I was getting at.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 7, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426293, "id": "c029ibz", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029ibz", "parent_id": "t1_c029hkj", "body": "Standard implementations of fold(l|r) are completely sequential, too.\r\n\r\nIf you calculate the sum of a sequence of values manually, you add the second value to the first value. Then you add the third value to the result etc...\r\n\r\nThats exactly what foldl1 (+) does.\r\n\r\nOn the other hand, I agree that lazy evaluation can lead to non-intuitive behaviour.", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "grauenwolf", "created_utc": "1192567269", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192618699", "ups": 1, "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426231, "score": 1, "body": "Dare I say \"database programmer != human\" ;-)\n\nBut, yes, that's true. It's another paradigm where we're not in \"sequential mode\".\n\nPlease note that probably the most important SQL dialect is PL/SQL, and one reason for that is that it has most imperative functionalities built in. It's telling, even if the other big reason is that it's \"Oracle inside\".", "id": "c029n23", "author": "Gotebe", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029n23", "parent_id": "t1_c029jrn", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029jrn", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 6, "link_id": "t3_5yek3", "retrieved_on": 1427426274, "body": "&gt;  We think sequentially, period\r\n\r\nYea, tell that to any database programmer.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029hkj", "id": "c029jrn", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029hkj", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": -7, "link_id": "t3_5yek3", "retrieved_on": 1427426302, "body": "Yes, I too, am astounded that so little people overlook that aspect. We think sequentially, period (at least, it's the default mode ;-)). FP goes against it. *Big* drawback.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029hin", "id": "c029hkj", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426302, "subreddit_id": "t5_2fwo", "archived": true, "ups": 21, "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 21, "id": "c029hl1", "author": "me2i81", "created_utc": "1192549053", "distinguished": null, "edited": false, "body": "A huge number of security bugs are due to experienced people screwing up for loops. ", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029hl1", "parent_id": "t1_c029hin", "score_hidden": false, "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 11, "author": "wozer", "created_utc": "1192549225", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 8, "author": "SuperGrade", "created_utc": "1192549748", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "redditnoob", "created_utc": "1192551593", "children": [{"controversiality": 0, "retrieved_on": 1427426296, "subreddit_id": "t5_2fwo", "archived": true, "ups": 11, "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 11, "body": "&gt; I know about the arguments for the theoretical beauty of fold and map and filter operations.\r\n\r\nNo, it's practical.  This has nothing to do with your \"feelings\", nor is strawmanning off into Paul Graham going to work.\r\n\r\n&gt; To me, my intuition argument stands. \r\n\r\nLearn it you'll get a new intuition.\r\n\r\n&gt; I think these examples with the for loop that are used to advocate FP are, in the larger sense, a pretty tiny and insignificant part of programming.\r\n\r\nA challenge here is that a more elaborate example is illegible to the target audience (people who are not familiar with the functional solution-space), the small ones are \"big deal, I can do that familiarly with just a couple of extra lines\" - along with the \"use smart programmers and you won't get the loop bugs you claim proliferate\" alongside \"problem with that functional mumbo-jumbo is it excludes less capable programmers\".\r\n\r\nExperience can make the program integrity and composition advantages apparent; but so can honest analysis of the 2 ways the same outcome can be programmed without bias toward the more familiar one.\r\n\r\n&gt;  The reason why FP doesn't factor strongly into programming contest results of any kind could be that despite whatever beauty it has to your inner pure mathematician it doesn't have a significant effect on real world productivity.\r\n\r\nI am not aware of a programming contest that yields codebases of the size and maintenance lifetime of a commercial product - \"real world productivity\" thus becomes an orthogonal issue from anything that can be learned in a programming contest.\r\n\r\n  ", "author": "SuperGrade", "created_utc": "1192553010", "distinguished": null, "edited": false, "id": "c029i1f", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029i1f", "parent_id": "t1_c029hva", "score_hidden": false, "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 8, "author": "grauenwolf", "created_utc": "1192567170", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": -1, "author": "redditnoob", "created_utc": "1192571669", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192573816", "ups": 2, "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426265, "score": 2, "body": "&gt; Your example benefits from the choice of line break conventions.\r\n\r\nNot really, VB has line-terminated statements.\r\n\r\n&gt; Ultimately after compilation it's going to be a for loop anyway, and there is also going to be overhead to that function call, isn't there? (In a blue sky future which we may see later, compilers may grab it and parallelize and produce code even faster.)\r\n\r\nNo blue-sky here, VB uses a JIT that will inline functions as it sees fit. Since this is a post-compile time process, the inlining can even occur across libraries.\r\n\r\n&gt; But the for loop to me is a perfect example of an good tradeoff between being aware of what the computer is actually doing (again, in our present time), and being simple.\r\n\r\nIn the simple case yes, but it creates a path for handling complicated code. \r\n\r\nConsider this task. Get a handle for all processes with a name matching the pattern \"*DevEn\" and using more than 1000000 of memory. Order the list by process name and PID.\r\n\r\nHere I show doing that using both LINQ and Dot notation:\r\n\r\n    Dim list = From P in Process.GetProcesses Where P.Name Like \"%DevEnv\" And P.WorkingSet &gt; 1000000 Order By P.Name\r\n\r\n    Dim list = Process.GetProcesses.Where(Function (p) p.Name Like \"%DevEnv\" And P.WorkingSet &gt; 100000).OrderBy( Function(p)  P.Name, Function(p)  P.PID)\r\n\r\nTo do the same thing using a for loop would require creating temporary collections for filtering and sorting, which certainly cannot be done in a single line.\r\n\r\nConsider another example:\r\n\r\n    Dim list = From a in ReallyBigList.ForParallel Where a.X &gt; 100 and a.Y = 50 \r\n\r\nBy merely adding \".ForParallel\", I turned this into a multi-threaded PLinq query wherein all the thread management and book-keeping is automatically performed for me. Like OpenMP, but with even less manual work.\r\n\r\n", "id": "c029keu", "author": "grauenwolf", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029keu", "parent_id": "t1_c029k97", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192575063", "ups": 6, "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426265, "score": 6, "body": "&gt; for(int i=0;i&lt;rows.length();i++) rows.objectAtIndex(i).doSomething();\n\nIt's not the \\*writing\\* that's the issue, it's the \\*reading\\*. I spend substantially more time reading code than I do writing it.\n\nOld-style Java loops throw too much syntactic noise at a reader (as does much of Java in general).", "author": "newton_dave", "archived": true, "distinguished": null, "edited": false, "id": "c029kio", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c029kio", "parent_id": "t1_c029k97", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029k97", "score_hidden": false, "controversiality": 0, "archived": true, "ups": -1, "link_id": "t3_5yek3", "retrieved_on": 1427426268, "id": "c029k97", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c029jr7", "body": "  Your example benefits from the choice of line break conventions.\n\nI can type pretty quickly :\n\nfor(Row r : rows) r.doSomething();\n\nIt makes me odd perhaps that even the following is ok by me (horror of horrors) :\n\nfor(int i=0;i&lt;rows.length();i++)\nrows.objectAtIndex(i).doSomething();\n\nIn practice, I can get the above or something equivalent with a few keystrokes in Eclipse anyway.\n\nIt just already seems about as atomic as it can get, especially in the first case. I know most of you think it's because I'm naive and haven't seen the light.\n\nUltimately after compilation it's going to be a for loop anyway, and there is also going to be overhead to that function call, isn't there? (In a blue sky future which we may see later, compilers may grab it and parallelize and produce code even faster.) But for something that to me doesn't make it any simpler, it hardly seems worth it.\n\nI know you could take the argument for being aware of the low level to extremes. It's certainly true that I don't want to know exactly how a loop is going to come out in terms of jump-not-equal assembly instructions. But the for loop to me is a perfect example of an good tradeoff between being aware of what the computer is actually doing (again, in our present time), and being simple.\n\nThe further point is more that the skeleton above is utterly trivial in any of these constructs. The real meat is going to be in the design of r, and what doSomething() actually does.  ", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 8, "name": "t1_c029jr7", "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426274, "score_hidden": false, "id": "c029jr7", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029hva", "body": "&gt; I know about the arguments for the theoretical beauty of fold and map and filter operations.\r\n\r\nScrew theory; what can fold and map do for me?\r\n\r\nAnswer:\r\n\r\n    for i = 0 to rows.count-1\r\n        Dim r = rows(r)\r\n        r.DoSomething()\r\n    next\r\n\r\n    for each r in rows\r\n        r.DoSomething()\r\n    next\r\n\r\n    rows.Action( Function(r) r.DoSomething() )\r\n\r\nFrom where I stand, map and fold are the logical next step from a For Each loop. But just as the For Each loop doesn't completely replace the For loop, map and fold don't completely replace For Each.\r\n\r\nNow if a VB programmer can understand how FP makes his life easier, there is no excuse for the rest of you.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 3, "name": "t1_c029hva", "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426298, "score_hidden": false, "id": "c029hva", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029ho7", "body": "I know about the arguments for the theoretical beauty of fold and map and filter operations. I agree that sloppy programmers can mess up for loops, but I have faith that if they have a flexible enough mind to grasp FP, they could find some interesting damage to do by lexicographical means as well:)\n\nI guess you can cite an argument like Paul Graham would use that a reason to use FP is because you will be working with a select group of smarter people. But the million dollar question is always whether the same group of selected people couldn't be just as productive with more conventional programming, putting the same thought and care into it.\n\nTo me, my intuition argument stands. I know which way this crowd feels about it, and I expect my sincere thoughts to get down-modded. I think these examples with the for loop that are used to advocate FP are, in the larger sense, a pretty tiny and insignificant part of programming. (Functions as data in general however, is of course not at all a tiny or insignificant concept.) To me it's sort of akin to someone claiming increased writing productivity by not dotting their i's anymore.\n\nThe author of the parent article seems to make every excuse for not considering the simplest explanation: The reason why FP doesn't factor strongly into programming contest results of any kind could be that despite whatever beauty it has to your inner pure mathematician it doesn't have a significant effect on real world productivity.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c029ho7", "controversiality": 0, "archived": true, "ups": 8, "link_id": "t3_5yek3", "retrieved_on": 1427426301, "id": "c029ho7", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029hlx", "body": "It's important to get *used to* both ways of expressing the problem.\r\n\r\nAn issue is composition - the for loop equivalent of \"map\" requires a container be preinitialized to empty then filled in a loop.  This creates the possibility of code being reordered/iffed out such that the container isn't filled, and the program will run on merrily.\r\n\r\nWant to omit/filter things from the list?  This requires an explicit step.  Interspersing items into a list (usually requiring some IsFirst flag)?  A step that can be filtered out into one function for a codebase, rather than statefully mixed in with the loop.\r\n\r\nThe functional approach lends opportunities for separation of what, by necessity, often otherwise need be piled into a for loop.  Patterns tend to emerge and become more visibly evident and factorizable.\r\n\r\nAlso, in functional code, every \"map\" highlights and guarantees a point where parallellization is possible (not necessarily desired; but possible) where a for loop cannot make such a guarantee (as the specification by the coder is of a sequence, not of ordered inputs + ordered outputs + action).\r\n\r\n", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 11, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426302, "id": "c029hlx", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029hlx", "parent_id": "t1_c029hin", "body": "&gt;I mean really, do you guys frequently screw up by using the wrong index or bound conditions after a year or so of programming practice?\r\n\r\nIn my experience, mistakes like that happen all the time on big projects, especially with a \"heterogenuous\" team of developers.\r\n(Trying to iterate backwards with an unsigned is especially nice:\r\n    for(unsigned i = size-1; i &gt;= 0; --i)\r\n.)\r\n\r\nWhether a for-loop or HOFs like map and fold feel more natural, is entirely a question of what you are used to.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192553522", "ups": 9, "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426295, "score": 9, "body": "&gt; I mean really, do you guys frequently screw up by using the wrong index or bound conditions after a year or so of programming practice?\r\n\r\nI see no advantages (other than familiarity to legacy programmers) to having the distinction exposed when dealing with N items.\r\n\r\n\r\n&gt;  I have to admit, I'm rooting against FP becoming mainstream. \r\n\r\nThat's kind of too bad; but you will learn.  Not through learning languages such as haskell; but by being on C# codebases with a Microsoft C# language development team stacked with Haskell programmers.\r\n\r\nThe \"lowest common denominator\" is being dragged in that direction via the mainstream development languages.  Functional (or list comprehension equivalents) coding constructs are being put in the mainstream languages, providing cover for developers who want to use them in mainstream products.\r\n\r\nThe L.C.D. will whine for a while, then get with the program, then wonder how they ever did without it - just like with all the other incremental changes from C that the \"mainstream\" slowly have put on their plate over the years.\r\n\r\n", "id": "c029i3q", "author": "SuperGrade", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029i3q", "parent_id": "t1_c029hin", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426253, "subreddit_id": "t5_2fwo", "created_utc": "1192587228", "ups": 5, "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 5, "id": "c029lcu", "author": "jmelesky", "archived": true, "distinguished": null, "edited": false, "body": "At some point, this was standard:\n\n    push returnAddr\n    push arg1\n    goto SUB\n\n    ...\n\n\n    SUB: pop arg1\n    ...\n    pop returnAddr\n    push result\n    goto returnAddr\n\nPeople did that all the time. It was incredibly intuitive to them.\n\nBut it was still error-prone and cumbersome. It became worthwhile to come up with a more abstract representation of the concept. So the subroutine (and, from it, structured programming) was born.\n\nYeah, for loops might be intuitive to you. But how often do you do for loops over an array or list, modifying each element in a predictable manner? If you're like me, you do it a lot. And so there i use an abstraction of that process: map or a list comprehension. Though there was an initial learning curve, maps are now incredibly intuitive to me.\n\nThey have become so intuitive, in fact, that i deal with them more easily than i deal with for loops, despite having learned programming in languages without those facilities.", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029lcu", "parent_id": "t1_c029hin", "score_hidden": false, "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "Tommah", "created_utc": "1192673091", "children": [{"controversiality": 0, "retrieved_on": 1427426157, "subreddit_id": "t5_2fwo", "archived": true, "ups": 1, "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 1, "body": "Yes, but so what? It's a simple operation, and simple to type. Or I can use keyboard shortcuts. Pay me off too for every time I've written a function declaration or assigned a variable.", "author": "redditnoob", "created_utc": "1192675614", "distinguished": null, "edited": false, "id": "c029srh", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029srh", "parent_id": "t1_c029sl0", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c029sl0", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426160, "score_hidden": false, "body": "&gt; For me, 'for(int i=0;i&lt;n;i++), or for(int i: array)' might as well be a keyword\n\n\"If I had a nickel for every time I've written 'for (i = 0; i &lt; N; i++)' in C I'd be a millionaire.\"   -- Mike Vanier", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029hin", "id": "c029sl0", "author_flair_css_class": null}], "subreddit": "programming", "ups": -7, "score_hidden": false, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426303, "body": "   I have to admit, I'm rooting against FP becoming mainstream. The for loop is a little bit dear to me because it's intuitive. If you give me, a person, a lot of numbers to add up, I go through one by one and add to the total. I don't conceive of a folding operation with a closure when I do so. I want adding to be something I do, not a noun I apply. There are times when it's clearly a powerful and simplifying tool to be passing functions around, but the reasons cited for why using some simple for loops is a big problem don't resonate with me at all. For me, 'for(int i=0;i&lt;n;i++), or for(int i: array)' might as well be a keyword, and I don't think abstraction beyond that is really helpful, because it already is extremely simple and intuitive. I mean really, do you guys frequently screw up by using the wrong index or bound conditions after a year or so of programming practice?   ", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029hin", "parent_id": "t3_5yek3", "id": "c029hin", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 5, "author": "UncleOxidant", "created_utc": "1192549175", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "kinebud", "created_utc": "1192563037", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 5, "author": "martinbishop", "created_utc": "1192564332", "children": [{"controversiality": 0, "retrieved_on": 1427426245, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029m0u", "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 2, "score_hidden": false, "body": "Nothing, as far as I know. It's just a (irrational?) feeling I get when I see code in ML-like languages. I guess you could just chalk it up to first impressions?", "author": "kinebud", "created_utc": "1192596185", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 2, "parent_id": "t1_c029jef", "id": "c029m0u", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c029jef", "controversiality": 0, "archived": true, "ups": 5, "link_id": "t3_5yek3", "retrieved_on": 1427426279, "id": "c029jef", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029j92", "body": "What's wrong with ML?", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 2, "name": "t1_c029j92", "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426280, "score_hidden": false, "id": "c029j92", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029hli", "body": "I don't know OCaml, but generally the attitude I've seen is that it slightly eschews the OO paradigm as it conflicts with its type system (or something or another.) Personally, I get a very intense feeling of dislike when I see ML based languages (generally, anyway) so you'd have to ask someone with more knowledge on it than me.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029je9", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426279, "score": 5, "id": "c029je9", "author": "martinbishop", "created_utc": "1192564323", "distinguished": null, "edited": false, "body": "OCaml and Haskell usually go back and forth in terms of winning the ICFP contests, look through the sites for the different years and you'll see this.  What does it mean? I don't know.", "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 5, "parent_id": "t1_c029hli", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192585990", "ups": 0, "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426254, "score": 0, "body": "I think it's more likely that OCaml is perceived as a faster language than Haskell, and the data processing in this year's contest made speed of execution very important.\n\nThe OO features of OCaml are not generally considered its strength (indeed, some have gone so far as to call it a misfeature). The writeups i've seen that used OCaml weren't using the OO features at all.", "author": "jmelesky", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029la4", "parent_id": "t1_c029hli", "score_hidden": false, "id": "c029la4"}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1192672373", "name": "t1_c029sjc", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426160, "score": 1, "score_hidden": false, "body": "That may be, but it depends on the problem, too.  I recall reading that one year's competition really favored lazy evaluation, so the Haskell entries beat out the others.  I don't remember what the question was from that year.", "author": "Tommah", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029hli", "id": "c029sjc", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 5, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426302, "body": "I seem to recall that in previous years functional languages did quite well in the IFCP.  This year OCaml had more in the top 10 than Haskell.  Is that because OCaml is really a multi-paradigm language in which you can do FP as well as stateful OOP?  \r\n\r\n", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029hli", "parent_id": "t3_5yek3", "id": "c029hli", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "brickbybrick", "created_utc": "1192549783", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "ansible", "created_utc": "1192551222", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1192560254", "name": "t1_c029iw9", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426286, "score": 1, "score_hidden": false, "id": "c029iw9", "author": "awj", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029htw", "body": "&gt; and I don't recall reading what exactly those problems are that aren't supposed to work well with FP.\n\nThey are probably similar to the kinds of problems that pure imperative programmers claimed OOP couldn't solve - ones that were impossibly difficult with their current level of understanding and/or the OOP system in question.", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 4, "author": "[deleted]", "created_utc": "1192564784", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029kr9", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426261, "score": 1, "score_hidden": false, "body": "I can see how state threading would get more difficult in large apps.\n\nPossible solutions include going the Erlang route of using many small message-passing processes.  I'm not aware of anyone doing this for pure FPLs though.\n\nAnother approach is [Functional Reactive Programming](http://www.haskell.org/frp/) in Haskell.  However, this hasn't been used on a wide scale yet.  So while I think it is promising, the benefits of this approach remain to be proven.", "author": "ansible", "created_utc": "1192578697", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c029jgb", "id": "c029kr9", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029jgb", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 4, "link_id": "t3_5yek3", "retrieved_on": 1427426278, "id": "c029jgb", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029htw", "body": "[deleted]", "author_flair_css_class": null}], "subreddit": "programming", "ups": 6, "name": "t1_c029htw", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426299, "score_hidden": false, "body": "_The bottom line here is that functional programming is good for some problems, but a terrible match for others. By \"terrible\" I mean that you're fighting the paradigm every step of the way to do something that would be straightforward in an imperative language._\n\nOK, I've heard this assertion before... and I don't recall reading what exactly those problems are that aren't supposed to work well with FP.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029hoa", "id": "c029htw", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 8, "author": "UncleOxidant", "created_utc": "1192560864", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "grauenwolf", "created_utc": "1192567489", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "jdh30", "created_utc": "1192831909", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "grauenwolf", "created_utc": "1192832511", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "jdh30", "created_utc": "1192917507", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "grauenwolf", "created_utc": "1192930251", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "jdh30", "created_utc": "1192999003", "children": [{"controversiality": 0, "retrieved_on": 1427425829, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02ai38", "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 1, "score_hidden": false, "body": "I'm looking at variants and pattern mataching, and I don't see any reason why they cannot be added to either VB or C#. Variants would use the same special-case mechanism they used for Nullable&lt;T&gt; types, and pattern matching isn't really that interesting from a compiler perspective.\r\n\r\nVB, which seemlessly deals with late binding, doesn't even need variant types to support pattern matching. \r\n\r\nType inference, now that is an interesting concept. You couldn't use it on public APIs, it would make them too fragile. (Same reason why duck typing will never really work for library writers.) But I could see them being combined with dynamic interfaces, a much needed feature for working with anonymous types.\r\n\r\nI'm not saying VB/C# will ever get these, but the possibility exists.", "author": "grauenwolf", "created_utc": "1193028073", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02afro", "id": "c02ai38", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427425859, "id": "c02afro", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02afro", "parent_id": "t1_c02abyc", "body": "The utility of closures in MLs like F# stems from concise representations of higher-order functions, curried functions, combinators and continuation passing style. None of these are achievable in VB or C# with comparable brevity.\r\n\r\nThe type inference capabilities of VB and C# will remain in a different league.\r\n\r\nI was referring to \"variant types\" in SML, OCaml, Haskell, etc.\r\n", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02abyc", "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427425908, "score_hidden": false, "id": "c02abyc", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c02ab1g", "body": "&gt; They only just got generics and a weak form of closures. \r\n\r\nThey got generics two years ago, which is also when C# got closures.\r\n\r\n&gt; Rudimentary forms of type inference have been hinted, and that is mundane among modern FPLs.\r\n\r\nHinted? The type inference capabilities, and limitations, in the next version of both languages have been clearly documented for several years now.\r\n\r\n\r\nBefore we go any further, why do you say C# closures are \"weak\"? And what would be a \"strong\" closure?\r\n\r\nAlso, please define \"variant types\". Clearly you don't mean variant types as defined in Wikipedia: http://en.wikipedia.org/wiki/Variant_type", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427425920, "id": "c02ab1g", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02ab1g", "parent_id": "t1_c02a5xs", "body": "VB and C# will not be getting a lot of the good things that F# offers. They only just got generics and a weak form of closures. Rudimentary forms of type inference have been hinted, and that is mundane among modern FPLs.\r\n\r\nVB and C# are years away from having anything like the primary benefits of F#, like variant types and pattern matching.\r\n", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427425986, "id": "c02a5xs", "author_flair_text": null, "distinguished": null, "edited": true, "name": "t1_c02a5xs", "parent_id": "t1_c02a5ve", "body": "That certainly is a wild-card. \r\n\r\nRight now I don't see it becomming real popular, as VB and C# will be getting a lot of the good things that F# offers. But then again I find myself writing about it a lot on InfoQ, and I don't even like functional langauges.\r\n\r\nNo matter how this plays out, it will be interesting. ", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02a5ve", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5yek3", "retrieved_on": 1427425987, "id": "c02a5ve", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029jsg", "body": "F#?", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426273, "id": "c029jsg", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029jsg", "parent_id": "t1_c029iz6", "body": "&gt; will the multi-paradigm nature of OCaml (or another similar multi-paradigm language) win out?\r\n\r\nDoubtful, too few people know them. I'm placing my bets on multi-paradigm langauges that are based on OOP and structural programming like Ruby, C#, and VB.\r\n\r\nThere is no technical reason I can think of that OCaml won't be the multi-paradigm language of the future, I'm speaking purely from culture and economics.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192831962", "ups": 1, "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427425987, "score": 1, "body": "Interesting. Poor performance is the reason I stopped learning Haskell, rather than the intrusively of being purely functional.", "id": "c02a5vr", "author": "jdh30", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02a5vr", "parent_id": "t1_c029iz6", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029iz6", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 8, "link_id": "t3_5yek3", "retrieved_on": 1427426284, "body": "This is why I chose to learn OCaml instead of Haskell.  Haskell's purity might be better for pedantic reasons (for getting into the FP mindset) - however, my approach to learning OCaml is to ignore the OO/imperative features initially and try to use only the purely functional aspects of OCaml initially for some programming exercises.  Later on I figure I can then add the OO/imperative features.  So far that seems to be working and I am getting to the \"aha\" moments related to FP and how learning it can change your thinking.\n\nCurrently it seems like Haskell is more popular, but ultimately, will the multi-paradigm nature of OCaml (or another similar multi-paradigm language) win out?", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029hoa", "id": "c029iz6", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426301, "id": "c029hoa", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029hoa", "parent_id": "t3_5yek3", "body": "The bottom line here is that functional programming is good for some problems, but a terrible match for others.  By \"terrible\" I mean that you're fighting the paradigm every step of the way to do something that would be straightforward in an imperative language.\n\nMost imperative languages, by comparison, doesn't go down the \"terrible\" road nearly as far, even for tasks that are best suited to Haskell.\n\nThis is clearly an argument for multi-paradigm languages.", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "risottoinc", "created_utc": "1192556708", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "dons", "created_utc": "1192590605", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192596512", "name": "t1_c029m1m", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426244, "score": 1, "score_hidden": false, "body": "I stand corrected. The full PDF does state that 26 teams were used Ruby.", "author": "risottoinc", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c029ll9", "id": "c029m1m", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "archived": true, "link_id": "t3_5yek3", "retrieved_on": 1427426250, "id": "c029ll9", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029ll9", "parent_id": "t1_c029igx", "body": "Ruby is definitely used (there were around 1000 teams all up this year, and some had \"ruby\" in their name). They just never do very well.\n\nEveryone asks why C++ beats Haskell and OCaml for the first time in 6 years, but no one seems to be asking why the `scripting' languages do so poorly. And I don't really know why this would be the case.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 2, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426292, "body": " Nobody used Ruby for the ICFP? Interesting...", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029igx", "parent_id": "t3_5yek3", "id": "c029igx", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c029jec", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426279, "score": 7, "score_hidden": false, "id": "c029jec", "author": "[deleted]", "created_utc": "1192564326", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 7, "parent_id": "t3_5yek3", "body": "&gt; Oh you Perl troll, it's just plain bull's droppings. Functional languages are not used because programmers are not clever enough to appreciate them.\n&gt; What they basically want is a C syntax language with C expressive power, it doesn't matter that it is named Java, and they are scared of anything abstract and powerful.\n\nBest comment ever!", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "dons", "created_utc": "1192571103", "children": [{"controversiality": 0, "retrieved_on": 1427426258, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029kze", "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 1, "score_hidden": false, "id": "c029kze", "author": "[deleted]", "created_utc": "1192582366", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029k79", "body": "[deleted]", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029l8s", "gilded": 0, "link_id": "t3_5yek3", "retrieved_on": 1427426255, "score": 3, "score_hidden": false, "id": "c029l8s", "author": "Korollary", "created_utc": "1192585527", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 3, "parent_id": "t1_c029k79", "body": "No, you don't understand. What you do is cherry-pick the data to support your own conclusion. All the previous years are irrelevant.\n\nNonetheless, the ICFP contest \"results\" are quite useless. (Begin rant) Specifically, the winning language of a given year is irrelevant. You can write correct programs in every language. Given that the participant skills is never equally distributed, if you have a particularly good hacker entering the contest year after year, his language will win year after year.\n\nWhat really matters is the cumulative success of all participants using language X. You want to look at languages with the highest average score with high enough standard deviation to reach near the top of the score table. (end rant)", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426235, "subreddit_id": "t5_2fwo", "created_utc": "1192611873", "name": "t1_c029mt5", "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 1, "score_hidden": false, "body": "C/C++ has really won 4. Cilk is C with some extra stuff for parallel programming, and last year's winners mostly used C++, but they listed 2D instead, which was a language you had to use for part of the problem.\n\nLike Korollary says, it's really about the people not the languages. There's a lot of FP programmers entering since this contest is run by a FP conference, but there's lots of good programmers entering with other languages too.", "author": "xhacker", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029k79", "id": "c029mt5", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 6, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426268, "body": "So in the past 9 years, iirc, we've had 4 Haskell wins, 3 OCaml wins and 2 from C++.\n\nI'm not sure we can conclude the death of FP from that sequence...\n\nThough it does say something very interesting about compiled, statically typed languages versus dynamic, interpreted ones. Hmm.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029k79", "parent_id": "t3_5yek3", "id": "c029k79", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -7, "author": "[deleted]", "created_utc": "1192604181", "children": [{"controversiality": 0, "retrieved_on": 1427426159, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029sli", "gilded": 0, "link_id": "t3_5yek3", "downs": 0, "score": 1, "score_hidden": false, "id": "c029sli", "author": "Tommah", "created_utc": "1192673275", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029mgr", "body": "Damn, are you in the wrong building.\n\nBy the way, why did you spell \"turkey\" with an N?", "author_flair_css_class": null}], "subreddit": "programming", "ups": -7, "name": "t1_c029mgr", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yek3", "retrieved_on": 1427426239, "score_hidden": false, "body": "[deleted]", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5yek3", "id": "c029mgr", "author_flair_css_class": null}