{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 41, "author": "happyhappyhappy", "created_utc": "1192640155", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 35, "author": "dons", "created_utc": "1192643622", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 11, "author": "happyhappyhappy", "created_utc": "1192645771", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "mr_chromatic", "created_utc": "1192649308", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 6, "author": "fmota", "created_utc": "1192655654", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 11, "author": "mr_chromatic", "created_utc": "1192657472", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192658061", "ups": 2, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426177, "score": 2, "body": "Oh I was really just kidding. No worries. :)", "id": "c029r7t", "author": "fmota", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029r7t", "parent_id": "t1_c029r5z", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029rhi", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426174, "score": 10, "score_hidden": false, "id": "c029rhi", "author": "dons", "created_utc": "1192660376", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 10, "parent_id": "t1_c029r5z", "body": "Thanks! :)", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 11, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426178, "id": "c029r5z", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029r5z", "parent_id": "t1_c029qzc", "body": "Oh no, I didn't mean to offend anyone in particular.  To the contrary: what Don, Brian, and John are doing impresses me greatly (and I argued very strongly within O'Reilly that we should sign their book.)", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029qzc", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 6, "link_id": "t3_5yigz", "retrieved_on": 1427426180, "body": "Are you trying to take a dig at me?\n\nI'm only very slightly offended, but well done anyway.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029q69", "id": "c029qzc", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426192, "id": "c029q69", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029q69", "parent_id": "t1_c029pmr", "body": "They're too busy doing cool stuff to dash off Yet Another Silly Monad Tutorial From Someone Who Just Learned Haskell.", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 16, "author": "augustss", "created_utc": "1192650623", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": -2, "author": "qwe1234", "created_utc": "1192725465", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 6, "author": "augustss", "created_utc": "1192727500", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 5, "author": "qwe1234", "created_utc": "1192727798", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 8, "author": "augustss", "created_utc": "1192729596", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "archived": true, "ups": 2, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426040, "score": 2, "id": "c02a1tx", "author": "qwe1234", "created_utc": "1192792843", "distinguished": null, "edited": false, "body": "cool.", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02a1tx", "parent_id": "t1_c029wnz", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029wnz", "ups": 8, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426107, "score_hidden": false, "body": "At the bank the only users are internal; we don't produce software for external use.  The DSEL itself is used by non-Haskell people.\n\nThe compiler sold by Bluespec is written in Haskell and is intended for end users (who get an executable and don't care what it's written in).\n\nThe partial evaluator is one program in a suite that is sold and is run by the end user.  (BTW, this program was first used in 1995 running on HP boxes.)\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029wfm", "id": "c029wnz", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 5, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426110, "id": "c029wfm", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029wfm", "parent_id": "t1_c029wel", "body": "are these internal tools or are the 'deliverables' used by actual users?", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426109, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029wh3", "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 1, "score_hidden": false, "body": "ObQwe1234:\n\n&gt; doesn't matter. haskell isn't viable for production code.\n\n&gt; and by production code i mean \"used by actual users\".\n\n&gt; and by \"actual users\" i mean at least a million a day.\n\n&gt; and by \"a million a day\" i mean \"all at the same time\".\n\n&gt; and by \"viable\" i mean \"produces the exact same results a c++ compiler would\".\n\n&gt; no thanks. you can keep your little toy apps. the work i do is far too complex to be entrusted to the likes of haskell. c++ ftw!", "author": "bitwize", "created_utc": "1192728098", "distinguished": null, "edited": true, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029wel", "id": "c029wh3", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426106, "subreddit_id": "t5_2fwo", "created_utc": "1192729806", "name": "t1_c029wow", "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 4, "score_hidden": false, "id": "c029wow", "author": "augustss", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 4, "parent_id": "t1_c029wel", "body": "Oh, I forgot another program that is being sold.  It translates Cryptol to FPGAs.  It's hard to tell how many users it has because the customers tell you nothing.  http://www.cryptol.net/", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 6, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426110, "body": "Yes.  The programs are large as Haskell programs go and they are real.\n\nCurrently I'm working for an investment bank.  The code is used daily by a number of people here.  All I can say is that it is a DSEL.\n\nBefore that I worked on a compiler for a hardware design language.  You can check out the web site of the company, bluespec.com.\n\nBefore that I wrote a partial evaluator that was (is?) used by Carmen Systems (carmen.se).  Their software is used by most major airlines around the world for crew scheduling.\n\nAll in Haskell, of course.\n\n(I've done other things in between, of course.  Like writing device drivers in C.)\n", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029wel", "parent_id": "t1_c029w6n", "id": "c029wel", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": -2, "name": "t1_c029w6n", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426113, "score_hidden": false, "body": "do you write large real program in Haskell?\n\nwhat field is it in?\n\nno, really.  :) ", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029qcn", "id": "c029w6n", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 16, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426188, "id": "c029qcn", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029qcn", "parent_id": "t1_c029pmr", "body": "Well, those of us who use Haskell for writing large real programs are not always at liberty to blog about what we are doing.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029t6x", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426152, "score": 2, "score_hidden": false, "body": "[deleted]", "author": "[deleted]", "created_utc": "1192682298", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 2, "parent_id": "t1_c029pmr", "id": "c029t6x", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029pmr", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 11, "link_id": "t3_5yigz", "retrieved_on": 1427426198, "id": "c029pmr", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029pd3", "body": "That's great!  You guys need to be blogging a lot more than enamored ungrads.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029uhv", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426136, "score": 2, "score_hidden": false, "id": "c029uhv", "author": "davidw", "created_utc": "1192709359", "distinguished": null, "edited": true, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 2, "parent_id": "t1_c029pd3", "body": " Haskell needs something practical where it stomps the competition into the ground.\n\nJoe Armstrong gets it:\n\nhttp://article.gmane.org/gmane.comp.lang.erlang.general/24512 \n", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029pd3", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 35, "link_id": "t3_5yigz", "retrieved_on": 1427426201, "id": "c029pd3", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c029ovt", "body": " Sure we are. Visit realworldhaskell.org or go see the videos of the Commercial User's of Haskell Workshop.\n\nThe issues in the large are which libraries to use, how to use purity and types to structure applications for maintainability and refactoring, build times for GHC, testing with QuickCheck, how to find Haskell devs, and so forth. We talk about these *all the time*. ", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 16, "author": "mr_luc", "created_utc": "1192644451", "children": [{"controversiality": 0, "retrieved_on": 1427426199, "subreddit_id": "t5_2fwo", "archived": true, "ups": 16, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 16, "body": "Start on hackage.haskell.org. That's the freshest place for code.\n\nYou can use the search facility to find the apps and libraries that are used by the most projects, and it is these that are likely to provide good examples for coding in the large.", "author": "dons", "created_utc": "1192645005", "distinguished": null, "edited": false, "id": "c029pjq", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029pjq", "parent_id": "t1_c029ph5", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1192645117", "name": "t1_c029pk6", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426199, "score": 13, "score_hidden": false, "body": "Does derivitives pricing running on 1000's of CPU's nightly count?  [And I'm not even a haskeller.]\n\nhttp://cufp.galois.com/slides/2006/HowardMansell.pdf", "author": "logistix", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 13, "parent_id": "t1_c029ph5", "id": "c029pk6", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "revence27", "created_utc": "1192689165", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c029v94", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426125, "score": 2, "score_hidden": false, "id": "c029v94", "author": "jerf", "created_utc": "1192717991", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 2, "parent_id": "t1_c029tni", "body": "&gt; HAppS\n\nI don't count this one. I tried to use it and it's effectively totally undocumented at this time. \n\nThe previous version is only useful if you don't mind tossing out your entire state every time you want to make a change to the type of your state, i.e., utterly useless in practice.\n\nHAppS is nothing more than \"promising\", not proof that large projects can work in Haskell.", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c029tni", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426146, "score_hidden": false, "id": "c029tni", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c029ph5", "body": "1. HAppS\n2. Too many.\n3. Himerge (http://haskell.org/himerge), the GTK+ front-end to Gentoo's Emerge.\n4. GHC, Darcs, House (operating system) ... Wait for my startup. ;o)\n   ", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192690068", "name": "t1_c029tp5", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426145, "score": 1, "score_hidden": false, "id": "c029tp5", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c029ph5", "body": "[deleted]", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 16, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426200, "id": "c029ph5", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029ph5", "parent_id": "t1_c029ovt", "body": "I approve heartily of this complaint.\n\nI am learning Haskell right now, as a matter of fact, and I find it fascinating that a language so expressive can also be so performant and accessible/capable.\n\nSomeone should really get together examples of good, well-organized **large** Haskell projects. Not me. I mean **you** guys, the ones who aren't learning Haskell, the ones who have achieved a level of mastery. \n\nGive us examples of secure, robust and well-organized:\n\n - web server\n - web applications.\n - production-quality desktop software\n - any other large-scale \"showcase\" projects.\n\nPython has an incredible number of projects that fit this bill. Ruby has a substantial number. Common Lisp ditto, although with a lot of disclaimers, because by any metric it is easier to get started developing in Python and Ruby than it is in Common Lisp. (For other reasons than language/project quality: many developers trained in a Java/.NET background are going to be lost when suddenly transitioning to emacs with slime; lack of high-quality free lisps for windows although SBCL is slowly changing this; until somewhat recently, broken asdf-install on windows for all free lisps).\n\nHaskell is almost as easy to get going in as ruby from a language, tools and learning point of view. \n\nBut from the \"code to learn from\" point of view ... it's tough!\n\n(Disclaimer: poster is a CL/rubyphile who has only completed a couple of trivial for-fun hacks using Haskell, but who is working his way through the Haskell School of Expression and loving every page)", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "OMouse", "created_utc": "1192662153", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "qwe1234", "created_utc": "1192725708", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "noamsml", "created_utc": "1193341862", "children": [{"controversiality": 0, "retrieved_on": 1427425373, "subreddit_id": "t5_2fwo", "created_utc": "1193342364", "ups": -4, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": -4, "body": "barf. (vomiting sounds.)\n\n\nbuddy, you might try being 'ok' in just language X (instead of 'shitcode generator in language X') before attempting to be 'very good' at languages X and Y.\n\n", "author": "qwe1234", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit": "programming", "name": "t1_c02bbt6", "parent_id": "t1_c02bbqj", "score_hidden": false, "id": "c02bbt6"}], "subreddit_id": "t5_2fwo", "name": "t1_c02bbqj", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5yigz", "retrieved_on": 1427425375, "body": "Then again, if all you have is a hammer, everything you see is a nail. While it's good to be extremely good at X, being an \"X-only\" programmer narrows you considerably in what you can do and the ways you can think about programming. It is best to be very good at X and Y, and to be OK at Z, just in case. ", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029w7m", "id": "c02bbqj", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 0, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426113, "body": "*programming X will make you a better programmer in Y*\n\nnot necessarily. being really, really good in X is usually much better than being a student language dilettante in X, Y, Z and W.\n", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029w7m", "parent_id": "t1_c029rou", "id": "c029w7m", "author_flair_css_class": null}], "subreddit": "programming", "ups": 6, "name": "t1_c029rou", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426171, "score_hidden": false, "id": "c029rou", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029ovt", "body": "&gt;student language dilettantes\n\nSpeaking as one of those, there's nothing wrong with that. We get to see all the cool shit that can be done with lots of languages and don't risk becoming conservative in our language choice for the next project we have to tackle.\n\nBesides, programming X will make you a better programmer in Y.", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "[deleted]", "created_utc": "1192662897", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "catch23", "created_utc": "1192664759", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192665287", "ups": 22, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426168, "score": 22, "body": "ghc 12.5 can implement the device drivers in the type system!", "author": "dons", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029rz1", "parent_id": "t1_c029rxm", "score_hidden": false, "id": "c029rz1"}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 6, "author": "procrastitron", "created_utc": "1192682581", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 3, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426143, "score": 3, "id": "c029tug", "author": "catch23", "created_utc": "1192693484", "distinguished": null, "edited": false, "body": "You've clearly never been able to recognize \"Enterprise\" sarcasm that required \"humor in the large\"", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c029tug", "parent_id": "t1_c029t7u", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029t7u", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 6, "link_id": "t3_5yigz", "retrieved_on": 1427426151, "body": "You've clearly never worked on an \"Enterprise\" system that required \"programming in the large\". Linux (or any systems software) doesn't count; it's a completely different beast.\n\nEnterprise systems are jokes. They are mash ups of all the latest buzz words (and legacy buzz words) that some PHB thinks are the wave of the future. As such they are bloated, slow monstrosities that require millions of lines of code to implement even basic functionality.\n\nI'm sure dibblego is right when he says he could have reimplemented those apps in a few thousand lines of Haskell. I also suspect that he could have reimplemented them in tens of thousands of lines of Java just by throwing out all of the \"Enterprise\" crap.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029rxm", "id": "c029t7u", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029rxm", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 2, "link_id": "t3_5yigz", "retrieved_on": 1427426168, "id": "c029rxm", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029rrl", "body": "Please rewrite our current linux kernel in a few thousand lines of Haskell.  That would save so much headache!  How about I give you a 200 line allowance to rewrite all the display drivers too?  That would be a nice to have.", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 5, "author": "catch23", "created_utc": "1192666466", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "[deleted]", "created_utc": "1192674874", "children": [{"controversiality": 0, "retrieved_on": 1427426145, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029tp0", "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 1, "score_hidden": false, "id": "c029tp0", "author": "malcontent", "created_utc": "1192689987", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029spl", "body": "Man you got punished for that HARD.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 0, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426158, "body": "[deleted]", "archived": true, "distinguished": null, "edited": true, "name": "t1_c029spl", "parent_id": "t1_c029s2l", "id": "c029spl", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 5, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426166, "id": "c029s2l", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029s2l", "parent_id": "t1_c029rrl", "body": "Maybe you could rewrite OpenOffice under 300 lines of Haskell?  That would sure make the product slimmer.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 3, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426170, "id": "c029rrl", "author_flair_text": null, "distinguished": null, "edited": true, "name": "t1_c029rrl", "parent_id": "t1_c029ovt", "body": "   &gt; write large, realistic programs\n\nI'd love to see one of those! Believe me, I've tried hard to find one.\n\nLet's put it another way, I worked for IBM on three projects during my time. One was 5MLOC of C code, another was 4.5MLOC of Java and the other one was big (I don't know for sure, but let's guess maybe 2MLOC of Java).\n\nSome of the fanboys were proclaiming these applications to be the most sophisticated and *largest* applications on the planet.\n\nI ask you, have *I* worked on the largest applications on the planet? Since, for me, there is nothing complex about millions and millions of lines of code of absolutely nothing at all (which is what these applications are).  I reject such a suggestion. \n\nThe fact of the matter is, I could rewrite them in a few thousand lines of Haskell. Only, the marketing department would disallow it, since clients wouldn't know what to do with something that exceeded their incredibly low standards of expectation.", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "revence27", "created_utc": "1192688905", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 5, "author": "[deleted]", "created_utc": "1192711093", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "revence27", "created_utc": "1192713615", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "[deleted]", "created_utc": "1192715226", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "vincentk", "created_utc": "1193433897", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "[deleted]", "created_utc": "1193434984", "children": [{"controversiality": 0, "retrieved_on": 1427425229, "subreddit_id": "t5_2fwo", "archived": true, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 1, "score_hidden": false, "body": " I perfectly agree. I primarily think of haskell's type system as a help for the _programmer_. E.g. you can be sure that third-party `strlen` is indeed thread-safe. \n\nCompiler optimizations are cool, but usually remain bonus material. ;-) ", "author": "vincentk", "created_utc": "1193477723", "distinguished": null, "edited": true, "id": "c02bmxi", "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02bkcq", "name": "t1_c02bmxi", "author_flair_css_class": null}], "subreddit": "programming", "ups": 2, "score_hidden": false, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427425262, "body": "That's true, though from a programmer's perspective, and not a compiler's perspective.  A compiler could easily recognize that the body of the function calls a non-const function on a global value, and mark it impure as a result.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02bkcq", "parent_id": "t1_c02bk8e", "id": "c02bkcq", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02bk8e", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_5yigz", "retrieved_on": 1427425264, "body": "  However, the `const` qualifier gives you no such guarantee in general. Consider this trivial modification of your example:\n\n    #include &lt;stdio.h&gt;\n\n    int strlen(const char *s) {\n        int i = 0;\n        close(stdout);\n        while(*s++) {\n            i++;\n        }\n        return i;\n     }\n\nHere, the type of the function remains unchanged. In haskell, on the other hand, this would change the type of a (ficticious) strlen function, from being, e.g. `[Char] -&gt; Int` to being something like `[Char] -&gt; IO Int`. Whatever your opinion regarding haskell, this has the advantage that you can confidently build larger pure functions from smaller ones, even if you're not intimately familiar with the implementation details of the latter (i.e. they were written by someone else).         ", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c029uy8", "id": "c02bk8e", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029uy8", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 3, "link_id": "t3_5yigz", "retrieved_on": 1427426129, "body": "They already do.  The compiler knows at compile time whether a given variable is global or local; this is necessary for proper scoping.  The problem is that there's no real optimization that can be done to strlen(3) based on that information.\n\nSeriously, what optimization would that knowledge enable for this code?\n\n    int strlen(const char *s) {\n        int i = 0;\n        while(*s++) {\n            i++;\n        }\n        return i;\n     }\n\nI can't think of any.  Furthermore, the const declaration indicates that strlen doesn't modify its argument, making strlen pure and thus just as optimizable by a C compiler as pure functions by a Haskell compiler.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029ut6", "id": "c029uy8", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426131, "id": "c029ut6", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029ut6", "parent_id": "t1_c029um0", "body": "&gt; ... proving correctness ...\n\nOops. Yeah. Testing only uncovers incorrectness, of course. It takes only an EWD to remember this. :o) My bad.\n\nStill ... ever wondered why the C compilers don't do this `simple analysis'?", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 5, "name": "t1_c029um0", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426133, "score_hidden": false, "body": "&gt; Testing (proving correctness)\n\nTesting doesn't prove correctness.  Testing disproves incorrectness in a limited number of cases (in particular, the cases tested).  Quickcheck's probabilistic testing, though swell, does not in any way *prove* correctness.  (A quality type system, on the other hand, *does* prove correctness, at least for certain program properties.  But even C++ provides a decent enough typesystem for those needs).\n\n&gt; If you can't be sure that C's strlen doesn't affect any global variables\n\nA ridiculously simple compiler analysis can uncover that fact. Next!", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c029tmz", "id": "c029um0", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": -1, "author": "qwe1234", "created_utc": "1192725916", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "dons", "created_utc": "1192776076", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192792960", "ups": -3, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426040, "score": -3, "id": "c02a1u6", "author": "qwe1234", "archived": true, "distinguished": null, "edited": false, "body": "*some* people do.\n\nthe ones writing software that doesn't involve recursive factorial or quicksort or monad combinators.", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02a1u6", "parent_id": "t1_c02a136", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02a1u7", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426040, "score": 1, "id": "c02a1u7", "author": "[deleted]", "created_utc": "1192792960", "distinguished": null, "edited": false, "body": "[deleted]", "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02a136", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "ups": 3, "name": "t1_c02a136", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426049, "score_hidden": false, "body": "Won't somebody think of the **value semantics**!??!", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029w8i", "id": "c02a136", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029w8i", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": -1, "link_id": "t3_5yigz", "retrieved_on": 1427426112, "body": "space/time complexity is often more important than correctness.\n\ncan quickcheck check for time complexity?\n\ni'd rather use c++, thanks. it's easier to add a unit test framework to idiomatic c++ than it is to add real value type semantics to haskell.\n\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029tmz", "id": "c029w8i", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029tmz", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5yigz", "retrieved_on": 1427426146, "body": "  Testing (proving correctness), for example, is something that matters when you `architect' a system.\n\nIt can't happen in C. Or Java, or whatever. All you do in them langauges is run the program and try to make it crash. That's different from what the Haskell type system and stuff like QuickCheck do for you.\n\n&gt; Let me state this very simply: The issue is not Haskell in the small.\n\nIt is the small things, comrade. It is the small things. If you can't be sure that C's `strlen` doesn't affect any global variables (and therefore can't parallelise it, for example), this _one single, simple function_, how much more a whole program?\nThe simple things `in the small' are the building blocks on which the entire system will stand. They matter the most.  ", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c029ovt", "id": "c029tmz", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 41, "name": "t1_c029ovt", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426207, "score_hidden": false, "id": "c029ovt", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t3_5yigz", "body": " Enough with the blind Haskell advocacy already!\n\nI learned Haskell years ago, before it was cool.  I own books about functional programming, and I know other FPLs too.  I am neither a functional programming fanboy nor bigot.\n\nLet me state this very simply:  The issue is not Haskell in the small.  The issue is not the \"weird\" Haskell features.  The issue is how to use Haskell to write large, realistic programs.  No one is talking about this stuff, and I get the strong impression that most of the Haskell fanboys are student language dilettantes with almost no engineering experience.  Almost certainly someone will respond that Haskell is perfectly suited for this stuff--better than C even--and there's no reason you couldn't write commercial video games or word processors in Haskell.  Fine.  *But no one is  talking about the issues involved with Haskell, or functional programming in general, in the large*.  How can you advocate a language as perfect for everything when you don't really have a clue how to architect projects using it?  \"Architect\" means more than \"Monads! Currying! Static typing!\"", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "k05h", "created_utc": "1192640353", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 4, "author": "micampe", "created_utc": "1192647068", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "piranha", "created_utc": "1192661090", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 4, "author": "fmota", "created_utc": "1192664545", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "piranha", "created_utc": "1192668556", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192674945", "ups": 3, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426158, "score": 3, "body": "No, I actually think it's a good point.\n\nHowever, some languages were made to be compiled, C being the obvious example. And some were made to be interpreted, such as Python.\n\nThat is, C was made to closely resemble the physical level, while for Python that isn't really an issue that gets any attention (and rightly so, IMO).\n\nHaskell probably falls somewhere in the middle - the unusual semantics keep it from being \"native\", but the strong typing makes it easier to infer meaning.", "id": "c029sps", "author": "fmota", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029sps", "parent_id": "t1_c029s8y", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 6, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426164, "body": " Languages aren't interpreted.  Programs are.  By implementations.\n\nWe have a [Python compiler for i386 machine-code](http://www.hl.id.au/Projects/pycro/).  And a [C interpreter](http://www.ddj.com/cpp/184402054).\n\n&lt;/semtroll&gt;", "archived": true, "distinguished": null, "edited": true, "name": "t1_c029s8y", "parent_id": "t1_c029rwp", "id": "c029s8y", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029rwp", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 4, "link_id": "t3_5yigz", "retrieved_on": 1427426168, "id": "c029rwp", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029rk6", "body": "He probably means any interpreted language.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426173, "id": "c029rk6", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029rk6", "parent_id": "t1_c029pu6", "body": "What's a \"non-native language\"?", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 4, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426195, "id": "c029pu6", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029pu6", "parent_id": "t1_c029owo", "body": "Just ask any Ruby developer. (ok, ok, any other non-native language would do ;)", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426145, "subreddit_id": "t5_2fwo", "created_utc": "1192690201", "ups": 1, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 1, "id": "c029tpg", "author": "revence27", "archived": true, "distinguished": null, "edited": false, "body": "Productivity is efficiency. See my earlier comment here. Valid question, upmodded (despite the downmods you just suffered).", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029tpg", "parent_id": "t1_c029owo", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029owo", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_5yigz", "retrieved_on": 1427426207, "body": "Most of the text is ok, but I don't understand why he talks about productivity in the efficiency question. ", "archived": true, "distinguished": null, "edited": true, "parent_id": "t3_5yigz", "id": "c029owo", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "noamsml", "created_utc": "1192646391", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 4, "author": "NilObject", "created_utc": "1192647247", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 14, "author": "llimllib", "created_utc": "1192647760", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "[deleted]", "created_utc": "1192712102", "children": [{"controversiality": 0, "retrieved_on": 1427426133, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029uos", "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 3, "score_hidden": false, "body": "C 2012 will be much faster than assembly as well.", "author": "llimllib", "created_utc": "1192712215", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 3, "parent_id": "t1_c029uoj", "id": "c029uos", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "chak", "created_utc": "1192764964", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "jdh30", "created_utc": "1192803997", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "augustss", "created_utc": "1192806836", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -3, "author": "jdh30", "created_utc": "1192828654", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "augustss", "created_utc": "1192869357", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "jdh30", "created_utc": "1192917998", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "augustss", "created_utc": "1192925399", "children": [{"controversiality": 0, "retrieved_on": 1427425858, "subreddit_id": "t5_2fwo", "created_utc": "1192999904", "name": "t1_c02afuy", "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 1, "score_hidden": false, "id": "c02afuy", "author": "jdh30", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02ablw", "body": "Looks like you found the ray tracer from your other post. The Haskell was optimized by all the gurus on their mailing list over a period of two weeks. The OCaml was optimized only by me and is ~3x faster here.\r\n\r\nI agree that there are arguments against specifying sematics to be undefined but I do not believe Haskell's idealistic approach is the answer either because it ignores the other half of the trade-off.\r\n\r\nFor example, when I started learning Haskell I was referred to a 3D shooter called Frag that is written entirely in Haskell. This is very interesting to me because it is related to my own work (scientific computing and visualization) and I was keen to see how Haskell fared. Sadly, it fared poorly. Despite being written in \"Haskell\", the code is unsafe and broken to the extent that it segfaults in 64-bit. Presumably the author only resorted to unsafe low-level code because Haskell was too slow. In contrast, OCaml and F# excel at these kinds of applications and are easily fast enough.\r\n", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "name": "t1_c02ablw", "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5yigz", "retrieved_on": 1427425913, "body": "If by Haskell you mean Haskell98, then I agree that it is in general slower than, say, OCaml.  \n(I don't think it is \"fundamental\" as is in theoretically impossible, though.)\nIf you use GHC with extensions for strict matching, unboxed types, etc, then I believe you can make Haskell as fast as OCaml.\n\nWhere is this ray tracer you keep bringing up?\n\nI have no problem with transformations that change undefined semantics (though I think undefined semantics is bad), but that's not the only problem with deforestation.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02ab2z", "id": "c02ablw", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "augustss", "created_utc": "1192928428", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "jdh30", "created_utc": "1192999384", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "augustss", "created_utc": "1193006126", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "vincentk", "created_utc": "1193040668", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "augustss", "created_utc": "1193043472", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "jdh30", "created_utc": "1193152764", "children": [{"controversiality": 0, "retrieved_on": 1427425527, "subreddit_id": "t5_2fwo", "created_utc": "1193270907", "ups": 2, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 2, "body": "   I took the 4th version of the code (so not the very fastest, I guess) and then I just translated the OCaml code straight to Haskell (standard Haskell 98, no extensions) without trying to be clever.  Here are the results:\n\n&gt;             Haskell    OCaml    C++\n&gt;       Time  12.6s      8.7s     5.0s\n&gt;       Chars 2446       2853     4291\n\nSo Haskell has a little slower and a slightly shorter.  I've not investigated why the Haskell code is slower.\n\nI'll send you the code if you want.\n ", "author": "augustss", "archived": true, "distinguished": null, "edited": true, "id": "c02b5dd", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02b5dd", "parent_id": "t1_c02at0t", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427425687, "id": "c02at0t", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02at0t", "parent_id": "t1_c02aixc", "body": "You might like to dig out the discussions from the Haskell-Cafe mailing list and add some contributions if you really can improve upon their code.\r\n\r\nWhat results do you get for the optimized (fastest) implementations? Don't bother optimizing the slower ones, of course...\r\n", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02aixc", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5yigz", "retrieved_on": 1427425818, "body": "I'll send it to you when I get home and have access to the code again.\nFor instance, the code was using bytestrings which is pointless when there's no string manipulation, it was also using foldl' on a 4 element list.  Little things like that.\n\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02aitz", "id": "c02aixc", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427425820, "body": "i would be very interested in seeing those changes. in particular the elimination of trivial, nonsensical stuff ;-)", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02aitz", "parent_id": "t1_c02agdn", "id": "c02aitz", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "vincentk", "created_utc": "1193041482", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "augustss", "created_utc": "1193043142", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193048409", "name": "t1_c02aj3y", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427425816, "score": 1, "score_hidden": false, "body": "for what it's worth, i'm getting 31s out of ghc 6.6, 83s out of ocamlopt 3.10, and 11s out of g++ 4.2 for that program. flags as advertised. this is a 1.83 GHz macbook here. another lunch break well spent ;-)", "author": "vincentk", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02aiwz", "id": "c02aj3y", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c02aiwz", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427425818, "score_hidden": false, "id": "c02aiwz", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02aiuz", "body": "I picked the least sophisticated program for OCaml and Haskell, compiled them with the given flags (except I used ghc 6.8), and ran them with the given flags.\n", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02aiuz", "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427425820, "score_hidden": false, "body": " the site compares ray tracers at different levels of sophistication. if you look at the [results section](http://www.ffconsultancy.com/languages/ray_tracer/results.html), you'll find that the most sophisticated ocaml version is about 5x (? they're a bit difficult to read) faster than the simplest one. \n\ni think the two of you are comparing different programs. still, their results indicate that the haskell version should be slower. ", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02agdn", "id": "c02aiuz", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02agdn", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 2, "link_id": "t3_5yigz", "retrieved_on": 1427425852, "id": "c02agdn", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02afsz", "body": "I doubt that it's 18x slower too.  I used exactly the compilation line from the web page.  I'd like to understand what's happening here, because the Haskell version should be decently fast, there's no essential laziness left.\n\nBTW, that code has not been gone over by any Haskell experts.  It has a number of trivial things that are jut nonsensical.  They don't matter for performance, but fixing them makes the code look nicer (not so many conversions, not so many parenthesis).\n", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193007637", "ups": 2, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427425850, "score": 2, "body": "I check my ocamlopt compilation again, I even looked at the assembly code.  It all looks fine.  And it runs about 3x slower than the Haskell code.\nPerhaps you should try GHC 6.8?  Oh, and don't use x86_64, that doesn't seem to perform well at all.\n\nIf you want, I can send you the changes I made to the code.  It's now neater, and takes command line arguments like all the others.\n", "author": "augustss", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02agho", "parent_id": "t1_c02afsz", "score_hidden": false, "id": "c02agho"}], "subreddit": "programming", "ups": 2, "name": "t1_c02afsz", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427425859, "score_hidden": false, "id": "c02afsz", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02abt7", "body": "OCaml takes 4.2s here. I doubt your computer is 18x slower than mine. What compile line did you use?\r\n", "author_flair_css_class": null}], "subreddit": "programming", "ups": 2, "name": "t1_c02abt7", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427425910, "score_hidden": false, "id": "c02abt7", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02ab2z", "body": "I found a ray tracer benchmark, http://www.ffconsultancy.com/languages/ray_tracer/benchmark.html, and I ran it on my MacBook.  It took 29s with GHC 6.8, and 76s with OCaml 3.10.0.\n\nMaybe I did something wrong, I didn't expect OCaml to be that slow.\n", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02ab2z", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5yigz", "retrieved_on": 1427425920, "id": "c02ab2z", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02a8e2", "body": "No. You cannot \"make Haskell run as fast\". That's my point: it is fundamentally slower. For example, can you make the Haskell ray tracer run as fast as the OCaml?\r\n\r\nTransformations that do not preserve undefined semantics are ubiquitous in mainstream compilers, let alone OCaml.\r\n", "author_flair_css_class": null}], "subreddit": "programming", "ups": 2, "name": "t1_c02a8e2", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427425956, "score_hidden": false, "body": "Did I claim that the extra optimization possibilities in Haskell outweighs the slowness of being lazy?  No.  I know as well as anyone how difficult it is to make Haskell  run fast.\nYou can write Haskell code that is as fast, but you often have to sacrifice the nice things about Haskell to do so.\nSo I think we pretty much agree on the speed of Haskell.  :)\n\nBut I totally disagree about a transformation that doesn't preserve semantics being valid.  If it doesn't preserve semantics it's just broken.\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02a5iz", "id": "c02a8e2", "author_flair_css_class": null}], "subreddit": "programming", "ups": -3, "name": "t1_c02a5iz", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427425992, "score_hidden": false, "id": "c02a5iz", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02a2ys", "body": "That's a triumph of hope over reality.\r\n\r\nWriting a sufficiently fast program can be impossible with Haskell but easy with most other compiled languages (even slow ones like Lisp and Java), e.g. the ray tracer.\r\n\r\nThat is why Haskell deserves its reputation of being slow: using Haskell can prevent your code from running at a competitive speed. This is the main reason I'm unlikely to write a \"Haskell for Scientists\".\r\n\r\nSome Haskell compilers happening to implement some forms of deforestation is a red herring. You can easily deforest eager code. Your implication that deforesting is \"invalid\" in eager languages is simply wrong. At best it is not semantics preserving, which is unimportant if the semantics are defined to be unspecified (which is often the case for evaluation order of HOFs).\r\n\r\nIndeed, Haskell is often criticized for being all theory and no practice and your example of a theoretical optimization that Haskell implements in the face of practical benchmark results that show Haskell to be slow is just another example of this.\r\n", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02a2ys", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 3, "link_id": "t3_5yigz", "retrieved_on": 1427426025, "id": "c02a2ys", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02a2mb", "body": "While it's true that some standard optimizations are more difficult because of laziness, it's also the case that there are some new ones that are only valid with laziness.  An example is deforestation of list processing.\n", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 0, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426029, "body": "Rubbish! Haskell does not provide the same optimization opportunities as almost all other compiled languages (C, C++, OCaml, F#, C#, Java etc.).\r\n\r\nJust like Python, Haskell can be competitively fast at certain operations but it is not uniformly fast.\r\n\r\nI think Haskell will get a bad name quite quickly if its community keep trying to pretend otherwise.\r\n", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02a2mb", "parent_id": "t1_c02a0do", "id": "c02a2mb", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 2, "name": "t1_c02a0do", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426058, "score_hidden": false, "body": "Ok, let me spell it out for you.  People who have not even bothered to look at the language (or at most gave it a cursory glance) make up some argument based on hear-say and handwaivy reasons for why Haskell must be having a performance problem.  dons, having written extremely efficient app/libs in Haskell (e.g., Yi, ByteString, xmonad), gets fed up and starts to talk about GHC 12.5.  It's funny, because it suggests how ridiculous the original arguments were without actually overtly offending anybody.\n\nBTW, when was the last time somebody argued that Perl/Python/Java/C# must be doomed to failure because their performance sucks?  This whole performance discussion is plainly silly.  Making jokes about it is the only way to stay sane.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029uoj", "id": "c02a0do", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029uoj", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 3, "link_id": "t3_5yigz", "retrieved_on": 1427426133, "body": "The Haskell mod squad is clearly on the warpath in this thread.  Original poster makes a reasonable assertion, gets downmodded.  Haskellers tell jokes about fictional compiler GHC 12.5, completely ignoring the actual claim made, and get upmodded to 10+.\n\nRidiculous.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029pxc", "id": "c029uoj", "author_flair_css_class": null}], "subreddit": "programming", "ups": 14, "name": "t1_c029pxc", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426195, "score_hidden": false, "id": "c029pxc", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029put", "body": "&gt; To assert that GHC 12.5 outperforms Assembly is absurd.\n\nso the master hit him harder with the stick, a second time...", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "SuperGrade", "created_utc": "1192649053", "children": [{"controversiality": 0, "retrieved_on": 1427426190, "subreddit_id": "t5_2fwo", "created_utc": "1192649994", "ups": 4, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 4, "id": "c029q9j", "author": "NilObject", "archived": true, "distinguished": null, "edited": false, "body": "He never mentions that the computer \"IS always running assembly.\" He only asserts that haskell outperforms assembly.\n\nI completely agree, you'd have to be a lunatic to write a complete program in assembly. However, to assert that Haskell is faster than assembly is lunacy as well.\n\nIf the argument was that the benefit of execution speed versus productivity is extremely higher in Haskell than any other language, I wouldn't have taken issue with that paragraph. But it's not; the original poster quoted him exactly: \"It outperforms assembly.\"", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029q9j", "parent_id": "t1_c029q55", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "ups": 0, "name": "t1_c029q55", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426192, "score_hidden": false, "id": "c029q55", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029put", "body": "As mentioned, the computer IS always running assembly.\r\n\r\nHowever, when doing a large project in assembly, one still writes the program partially to be human-editable.  You'll see this even writing a C++ program - you can change one line in the header that makes all the \"assembly\" change, whereas if you'd written all the assembly by hand you'd be less inclined to change every single piece of it when the spec changes.\r\n\r\nWith Haskell's lazy evaluation, you could probably can an example where its lazy evaluation prevents some calculation that writing something in a \"normal\" fashion would induce a calculation.\r\n\r\n\r\n\r\n", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 15, "author": "dons", "created_utc": "1192660909", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "archived": true, "ups": 1, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426171, "score": 1, "body": "[deleted]", "author": "[deleted]", "created_utc": "1192662273", "distinguished": null, "edited": true, "id": "c029rpd", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029rpd", "parent_id": "t1_c029rjj", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426171, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029rpj", "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 1, "score_hidden": false, "body": "[deleted]", "author": "[deleted]", "created_utc": "1192662347", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029rjj", "id": "c029rpj", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "[deleted]", "created_utc": "1192662719", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 4, "author": "fmota", "created_utc": "1192664480", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c029ryw", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426168, "score": 1, "score_hidden": false, "id": "c029ryw", "author": "[deleted]", "created_utc": "1192665235", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c029rwm", "body": "[deleted]", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029rwm", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 4, "link_id": "t3_5yigz", "retrieved_on": 1427426168, "id": "c029rwm", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029rqt", "body": "As long as you aren't the monkey operator `(:[])`", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029rzv", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426168, "score": 22, "score_hidden": false, "body": "After Chuck Norris helped Simon Peyton Jones fix the bugs in the GHC type checker, GHC 12.5 can statically guarantee you get laid.", "author": "dons", "created_utc": "1192665604", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 22, "parent_id": "t1_c029rqt", "id": "c029rzv", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c029rqt", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426170, "score_hidden": false, "body": "[deleted]", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029rjj", "id": "c029rqt", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "NilObject", "created_utc": "1192665875", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "logistix", "created_utc": "1192669379", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192682192", "ups": 1, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426152, "score": 1, "body": "I didn't pick up on the version, but I did get the ghc package installed on my Ubuntu machine. I even followed through the first few chapters of Write Yourself a Scheme in 48 Hours.", "author": "NilObject", "archived": true, "distinguished": null, "edited": false, "id": "c029t6l", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c029t6l", "parent_id": "t1_c029sbk", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029sbk", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 6, "link_id": "t3_5yigz", "retrieved_on": 1427426163, "body": "That was supposed to be a joke.  Current version of GHC is 6.something.  Of course it's unfair to assume people who don't follow haskell will pick up on the joke.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029s0p", "id": "c029sbk", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 0, "name": "t1_c029s0p", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426168, "score_hidden": false, "id": "c029s0p", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029rjj", "body": "I did after reading the article, and I'm not doubting that it's a great product, and that for the same amount of time spent on code in Haskell and Assembly, you'll have a more complete product that is faster. But to say that someone hand tweaking assembly could *never* outperform Haskell is something that can't be asserted.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 15, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426173, "body": "Seriously, you should try GHC 12.5. It has some cool features, like transparently parallelising your code, enabling it to scale up to forfty cores, and detecting non-terminating programs statically by their type.\n\nOh, and the IO monad is implicit.", "archived": true, "distinguished": null, "edited": true, "name": "t1_c029rjj", "parent_id": "t1_c029put", "id": "c029rjj", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029put", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 4, "link_id": "t3_5yigz", "retrieved_on": 1427426195, "body": "Not sure why he's getting downmodded. Haskell isn't magic. It still does stuff that must execute something on the processor. Assembly is just a human readable version of the instructions processors execute. Therefore, anything Haskell does could be written in Assembly.\n\nTo assert that GHC 12.5 outperforms Assembly is absurd.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029pqg", "id": "c029put", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 10, "author": "awj", "created_utc": "1192649058", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "NilObject", "created_utc": "1192682418", "children": [{"controversiality": 0, "retrieved_on": 1427426151, "subreddit_id": "t5_2fwo", "created_utc": "1192683474", "name": "t1_c029t9w", "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 3, "score_hidden": false, "body": "GHC version 12.5 doesn't exist.  It is fantasy.\n\nTherefore, it can outperform assembly if it wants to.\n\nNyah nyah nyah.", "author": "nmessenger", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 3, "parent_id": "t1_c029t7e", "id": "c029t9w", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426151, "body": "The claim \"It outperforms assembly\" can be disproven by this:\n\n* Compile your favorite haskell program.\n* Disassemble it (turn the executable in to assembly)\n* Pass the assembly code to the assembler.\n\nNow, the Haskell code is the exact same speed as the assembly code. *It does not outperform assembly.*", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029t7e", "parent_id": "t1_c029q56", "id": "c029t7e", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192712002", "ups": 1, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426133, "score": 1, "body": "&gt; Is it possible to write assembly code that can outperform compiled code? Hell yes. Is that likely to happen in the average case? Hell no.\n\nIs it possible to write Haskell, compile it, disassemble it, and then tweak the assembly to be faster?  Hell yes.  Ergo, Haskell (or any other language, for that matter) cannot outperform assembly.", "id": "c029uod", "author": "[deleted]", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029uod", "parent_id": "t1_c029q56", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029q56", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 10, "link_id": "t3_5yigz", "retrieved_on": 1427426192, "body": "&gt; It's impossible to outpreform assembly, by definition, because any and every program can be written in asm.\n\nTuring equivalence isn't true equivalence. There are a optimizations that a compiler can perform which I would be hard pressed to pull off throughout a program written in assembly. Is it possible to write assembly code that can outperform compiled code? Hell yes. Is that likely to happen in the average case? Hell no.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029pqg", "id": "c029q56", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192668581", "ups": 6, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426164, "score": 6, "id": "c029s94", "author": "Tommah", "archived": true, "distinguished": null, "edited": false, "body": "&gt; because any and every program can be written in asm.\n\nYou mean machine code.", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c029s94", "parent_id": "t1_c029pqg", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426196, "body": "\"It outperforms assembly.\"\n\nWhat does this mean? It's impossible to outpreform assembly, by definition, because any and every program can be written in asm.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029pqg", "parent_id": "t3_5yigz", "id": "c029pqg", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 8, "author": "punchjudy", "created_utc": "1192647116", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 4, "author": "awj", "created_utc": "1192649457", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "punchjudy", "created_utc": "1192685301", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "revence27", "created_utc": "1192690081", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 5, "author": "punchjudy", "created_utc": "1192695352", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "revence27", "created_utc": "1192699072", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029u56", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426139, "score": 2, "score_hidden": false, "body": "If the algorithm can't run fast enough in C, but it can in assembly, it's not ahead of its time, it's just ahead of your time. If you choose not to write it at all, then you're a picky programmer. I totally respect that, but don't blame the algorithm or the language.\n\nAnd by the way, you totally just contradicted what you said before:\n&gt; C isn't slow enough to make a good algorithm slow. If an algo is fast in assembly, it is fast in C. If it is too slow in C, it is too slow in assembly", "author": "punchjudy", "created_utc": "1192700638", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 2, "parent_id": "t1_c029u2r", "id": "c029u56", "author_flair_css_class": null}], "subreddit": "programming", "ups": 0, "name": "t1_c029u2r", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426140, "score_hidden": false, "id": "c029u2r", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029twy", "body": "&gt; If my algorithm can't run fast enough in C (but it can in assembly), it's ahead of its time.\n\nRight?\nIf we are ready to sink to the murky depths of C, then we should be just as ready to sink to the murkier depths of assembly for the sake of efficiency, the latest god in computing.\n\nI won't resort to assembly, to do PageRank on the\nPDP-10. Neither will I resort to C to do a QuickSort on the Intel Xeon Duo.", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "[deleted]", "created_utc": "1192711720", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "augustss", "created_utc": "1192747828", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "[deleted]", "created_utc": "1192757039", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1192778950", "name": "t1_c02a18h", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426048, "score": 2, "score_hidden": false, "body": "What about if you use \"natural merge sort\".  In natural merge sort you scan the input and divide it into already sorted subsequences and then you merge those.  So if the list is already sorted you get one subsequence and it runs in linear time.", "author": "augustss", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 2, "parent_id": "t1_c029zpt", "id": "c02a18h", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 0, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426067, "id": "c029zpt", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029zpt", "parent_id": "t1_c029yyj", "body": "No, not really.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426077, "id": "c029yyj", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029yyj", "parent_id": "t1_c029unn", "body": "Depends on which merge sort you use.", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c029unn", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426133, "score_hidden": false, "body": "&gt; Bubble sort will always be slower than merge sort.\n\nNot for already sorted lists :)", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029twy", "id": "c029unn", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 5, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426142, "body": " &gt; If an algo is fast in C, it is fast in Haskell.\n\nYes\n\n&gt; If it is too slow in Haskell, it is too slow in C, which makes it ahead of its time.\n\nWhat? An algorithm is just a mechanical method for solving a problem. If it's slow now, it's slow for eternity. Bubble sort will always be slower than merge sort. Bubble sort's time will never come. \n\nMaybe your talking about applications? Like streaming video decoding. Back in the day, computers couldn't handle it, now they can, using either C or Haskell, like you say. But if you have two algorithms for decoding video, and one is faster than the other, why would you ever use the slower one? \n\nLets do a little case analysis:\n\n&gt; If my algorithm can't run fast enough in Haskell or C, nor can any other algorithm...\n\nThen the application is ahead of its time.\n\n&gt; If my algorithm can't run fast enough in Haskell (but it can in C), it is ahead of its time.\n\nNo, you're just in the wrong industry. Choose the tools to fit the job, not the other way around.\n\n&gt; If my algorithm can't run fast enough in Haskell, but another algorithm can...\n\nThen use that other one! In any case, there's no excuse for using a slower algorithm. ", "archived": true, "distinguished": null, "edited": true, "name": "t1_c029twy", "parent_id": "t1_c029tp6", "id": "c029twy", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426030, "subreddit_id": "t5_2fwo", "archived": true, "ups": 0, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 0, "body": "Then why is optimized Haskell 3x slower than the fastest languages on the ray tracer language comparison?", "author": "jdh30", "created_utc": "1192803784", "distinguished": null, "edited": false, "id": "c02a2lj", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02a2lj", "parent_id": "t1_c029tp6", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 0, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426145, "body": "The keyword is `in Haskell'. Keyphrase, alright.\nHaskell isn't slow enough to make a good algorithm slow. If an algo is fast in C, it is fast in Haskell.\nIf it is too slow in Haskell, it is too slow in C, which makes it ahead of its time.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029tp6", "parent_id": "t1_c029tew", "id": "c029tp6", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426149, "body": " It looks like your downmod-whining paid off, but I'll bite anyway: When comparing two algorithms for speed, it's assumed that they both do the same thing, solve the same problem. Hardware arithmetic is not, and could not be arbitrarily precise, and everyone knows this.  It's supposed to be a case of \"all else being equal,\" which they are not in your examples. Have any other examples in which the development of a slower algorithm is considered 'progress' for any reason other than it being easier to teach? \n\nOh, and for the record, GHC uses libgmp, which is written in C. And yes I am aware of [this.](http://thread.gmane.org/gmane.comp.lang.haskell.libraries/7285)  ", "archived": true, "distinguished": null, "edited": true, "name": "t1_c029tew", "parent_id": "t1_c029q75", "id": "c029tew", "author_flair_css_class": null}], "subreddit": "programming", "ups": 4, "name": "t1_c029q75", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426190, "score_hidden": false, "id": "c029q75", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c029puc", "body": "&gt; WTF? Algorithms of the future are slower?\n\nYes, at least sometimes they are. Ref: arbitrarily large integers and mathematically correct ratios.\n\n*edit:* Anyone downmodding this want to tell my why the think I'm wrong?", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029puc", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 8, "link_id": "t3_5yigz", "retrieved_on": 1427426195, "id": "c029puc", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t3_5yigz", "body": "   &gt; Next Myth: Haskell is less-efficient than C. (Or C is more-efficient than\nHaskell.)\nAs always, I want you to qualify this statement with the implementation to which\nyou refer. You haven't seen my Haskell runtime written in hexadecimal. It\nout-performs assembly. And you haven't seen [GHC 12.5](http://c2.com/cgi/wiki?SufficientlySmartCompiler), either.\n\n...\n\n&gt; do you go to work for the computer, or for the computer to work for you?\n\nWe work together, actually. \n\n&gt; If my algorithm can't run fast enough in Haskell, it is ahead of its time.\n\nWTF? Algorithms of the future are slower? This paragraph is a big heap of fail. The rest makes sense, but trying to debunk this myth be redefining 'efficiency' only solidifies it as fact.    ", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 12, "author": "funshine", "created_utc": "1192649026", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 19, "author": "[deleted]", "created_utc": "1192657879", "children": [{"controversiality": 0, "retrieved_on": 1427426164, "subreddit_id": "t5_2fwo", "created_utc": "1192668437", "name": "t1_c029s8k", "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 12, "score_hidden": false, "body": "Har, har, har.  I hope she kicked you hard enough for all of us", "author": "Tommah", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 12, "parent_id": "t1_c029r7h", "id": "c029s8k", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 19, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426177, "body": "When I tried to explain to  this female the difference between function currying and partial application and got it wrong, she kicked me in the monads.\n", "archived": true, "distinguished": null, "edited": true, "name": "t1_c029r7h", "parent_id": "t1_c029q50", "id": "c029r7h", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192803697", "ups": 3, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426030, "score": 3, "score_hidden": false, "body": "You mean Haskell has Philippa and the other FPLs have nobody? ;-)\r\n", "author": "jdh30", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02a2l7", "parent_id": "t1_c029q50", "id": "c02a2l7", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 12, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426192, "body": "The author forgets one very important point: haskell is the language that has the highest proportion of female members in its community of enthusiasts.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029q50", "parent_id": "t3_5yigz", "id": "c029q50", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "seliopou", "created_utc": "1192649529", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 6, "author": "augustss", "created_utc": "1192650888", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "shit", "created_utc": "1192653553", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 13, "author": "augustss", "created_utc": "1192654529", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": -3, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427425991, "score": -3, "body": "Then this new definition of \"lazy\" applies everywhere and, consequently, conveys no information.\r\n", "author": "jdh30", "created_utc": "1192828909", "distinguished": null, "edited": false, "id": "c02a5k1", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02a5k1", "parent_id": "t1_c029qv6", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029qv6", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 13, "link_id": "t3_5yigz", "retrieved_on": 1427426182, "body": "But the operators/syntactic-forms that you call short circuiting behave exactly like functions with lazy evaluation.  That makes me inclined to say that these operators use lazy evaluation.\nOf course, the implementation of lazy operators in a strict language are not like the na\u00efve implementation of lazy evaluation (thunks, etc.).  But if you look at better compilers for lazy languages you'll see that they compile, e.g., &amp;&amp; just like C.\n ", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029qqp", "id": "c029qv6", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029qqp", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_5yigz", "retrieved_on": 1427426183, "body": "Lazy evaluation is implicit (and everywhere) in Haskell, short circuiting is usually explicit.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029qe1", "id": "c029qqp", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "seliopou", "created_utc": "1192654392", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 4, "author": "[deleted]", "created_utc": "1192663683", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "seliopou", "created_utc": "1192673489", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "[deleted]", "created_utc": "1192678973", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "seliopou", "created_utc": "1192716562", "children": [{"controversiality": 0, "retrieved_on": 1427426124, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c029vcj", "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 1, "score_hidden": false, "body": "Ah, the \"if of **any given programming language**\" part is what I wasn't getting.", "author": "[deleted]", "created_utc": "1192718660", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c029v2t", "id": "c029vcj", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426029, "subreddit_id": "t5_2fwo", "created_utc": "1192804287", "ups": 1, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 1, "id": "c02a2nn", "author": "jdh30", "archived": true, "distinguished": null, "edited": false, "body": "Yes. Don't forget that Haskellers don't take nomenclature to have its conventional meaning: they have their own set of definitions. Ask them what \"functional programming\" is, for example...\r\n", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02a2nn", "parent_id": "t1_c029v2t", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029v2t", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5yigz", "retrieved_on": 1427426128, "body": "Yes, the primitive 'if' of any given programming language is not a function in the language, but rather syntax, a control structure. Sure, in a lazy language you can write a function that behaves just like 'if', but what I was trying to say in my previous post is that the if you defined and the if of any given programming language are not evaluated in the same way.\n\nThe heart of the matter is this statement by the author: \"A jump is basically the most primitive mode of lazy evaluation. You evaluate as much as is needed, and then abandon the course. That's lazy. Lazy evaluation.\"\n\nTo call a jump a form of lazy evaluation is absurd. If is nothing more than a conditional jump.\n\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029sz7", "id": "c029v2t", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426155, "body": " You said that \"if\" isn't a function. Maybe I missed your original point.", "archived": true, "distinguished": null, "edited": true, "name": "t1_c029sz7", "parent_id": "t1_c029sm2", "id": "c029sz7", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029sm2", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426159, "id": "c029sm2", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c029rue", "body": " &gt;\"if\" can still be defined internally like this:\n\nIt can be, but that's not the built-in if of a lazy language. \n\n&gt;Then all instances of \"if a then b else c\" can be transformed into \"if a b c\" by the compiler.\n\nSure.\n\n&gt;Does this not fit the criteria of lazy evaluation?\n\nIf the language that your if is defined in is a lazy language, then yes. I don't see your point, or how this is at all relevant to the issue. ", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029rue", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 4, "link_id": "t3_5yigz", "retrieved_on": 1427426169, "body": "  \"if\" can still be defined internally like this:\n\n     if True  t _ = t\n     if False _ f = f\n\nThen all instances of \"if a then b else c\" can be transformed into \"if a b c\" by the compiler. Does this not fit the criteria of lazy evaluation?  ", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c029qui", "id": "c029rue", "author_flair_css_class": null}], "subreddit": "programming", "ups": 0, "name": "t1_c029qui", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426182, "score_hidden": false, "id": "c029qui", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c029qe1", "body": " First, I mistakenly referred to what he was describing as short-circuiting. It is not short-circuiting, though I still maintain what he was describing is not lazy evaluation.\n\nLazy evaluation refers to the way in which arguments to a function are evaluated at application. Under lazy evaluation an argument to a function is not evaulated until it is needed so that the evaluation of the function application can proceed.\n\n'if' is not a function. Nor is '?:'. They are control structure that differ fundamentally from functions in how they are evaluated. If 'if' were a lazy function, then it would take three arguments, and wrap those three arguments in thunks. The function would then force the evaluation of the first thunk (the condition) and then depending upon its value return the second or third thunk. This is not what 'if' does. 'if' only creates one thunk out of the branch that is returned based on the value of the condition. Or rather, it evaluates one of the branches based on the value of the condition; whether this is a thunk or not depends the language's evaluation strategy.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 6, "name": "t1_c029qe1", "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426188, "score_hidden": false, "id": "c029qe1", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c029q7d", "body": "So explain to me why they are different?", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029q7d", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5yigz", "retrieved_on": 1427426190, "id": "c029q7d", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5yigz", "body": "The author confuses short-circuiting and lazy evaluation. They're not the same thing.", "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427426180, "subreddit_id": "t5_2fwo", "created_utc": "1192655779", "ups": 11, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 11, "body": "Wow, it turns out Haskell has its own version of why the lucky stiff!\n", "author": "edheil", "archived": true, "distinguished": null, "edited": false, "id": "c029r03", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029r03", "parent_id": "t3_5yigz", "score_hidden": false, "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192665012", "ups": 7, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426168, "score": 7, "body": "There is #girlfriends?", "id": "c029rya", "author": "lothair", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029rya", "parent_id": "t3_5yigz", "score_hidden": false, "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 14, "author": "ubernostrum", "created_utc": "1192681288", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192689953", "name": "t1_c029tov", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426145, "score": -1, "score_hidden": false, "body": "Haskell programs generally don't do less laziness than equivalent C programs. It's just that the C programs implement it as a forest of interwoven and confusing if/case expressions.\nThe Haskell ones do it in thunks.\n\nThe Haskell community does more research than the C community as regards efficient lazy evaluation, even though both need it sorely. Who is sweeping this valid issue under the rug, of these two?\n\nApply the above the above statement replacing laziness with monads.\n\nEDIT: Where the C programs do less laziness, they do the wrong thing, ie, evaluate an experssion whose value is not needed.", "author": "revence27", "archived": true, "distinguished": null, "edited": true, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": -1, "parent_id": "t1_c029t4h", "id": "c029tov", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "taejo", "created_utc": "1192707919", "children": [{"controversiality": 0, "retrieved_on": 1427426122, "subreddit_id": "t5_2fwo", "created_utc": "1192719730", "ups": 6, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 6, "id": "c029vhl", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "body": "You don't need to know category theory to do anything, except maybe category theory.", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029vhl", "parent_id": "t1_c029ues", "score_hidden": false, "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "xenon", "created_utc": "1192742617", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192795105", "ups": 5, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426038, "score": 5, "body": "I was replying to \"[Haskell] attempts to impose a background in category theory on the user in order to explain how to open a file.\"\n\nIt doesn't.", "author": "taejo", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02a1yb", "parent_id": "t1_c029yf5", "score_hidden": false, "id": "c02a1yb"}], "subreddit": "programming", "score_hidden": false, "ups": 0, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426084, "body": "Way to not read the post you're replying to.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c029yf5", "parent_id": "t1_c029ues", "id": "c029yf5", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426136, "id": "c029ues", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029ues", "parent_id": "t1_c029t4h", "body": "Have you used Haskell? You really don't need to know category theory to do even extensive IO. \n\nIn fact, using do-notation in the IO monad is a lot like programming in C.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 4, "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426125, "score": 4, "id": "c029v89", "author": "jerf", "created_utc": "1192717817", "distinguished": null, "edited": true, "body": " &gt; But again, no other language takes it to such an extreme as Haskell, or attempts to impose a background in category theory on the user in order to explain how to open a file.\n\nArguably, Java does. A different theory, but as it has been pointed out, the minimal \"read from a file example\", to be fully understood, still requires an awful lot of rather tricky OO (the local category concept) to be understood.\n\nYou're just used to that, that's all. ", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c029v89", "parent_id": "t1_c029t4h", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 14, "controversiality": 0, "archived": true, "link_id": "t3_5yigz", "retrieved_on": 1427426153, "id": "c029t4h", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029t4h", "parent_id": "t3_5yigz", "body": "Some of these \"myths\" border on straw men set up for the sake of having something to argue with. Others are somewhat trickily responded to in ways which make it look like they've been disproved when actually they haven't.\n\nTake laziness, for example: yes, many languages have _some_ laziness features, I can't think of any which take laziness to such an extreme as Haskell. Many of its \"weird\" features stem directly from the fact that the laziness is everywhere, and thinking in terms of things which won't evaluate when you'd expect them to (or which may never evaluate at all) is a big part of the alleged steepness of Haskell's learning curve. Responding with \"well, other languages have some laziness features, and Haskell's implementation might change in the future\" is a poor attempt to sweep a valid point under the rug.\n\nThe same goes for the \"oh, other languages have monads\" argument. Other languages have things which, viewed in the appropriate light and with the appropriate understanding of both monads and the language, look like monads. But again, no other language takes it to such an extreme as Haskell, or attempts to impose a background in category theory on the user in order to explain how to open a file.\n\nAs for \"Haskell is difficult\", I'd argue that it's true this is not an inherent property of the language. Rather, it's a property of some members of the Haskell community; the most visible parts of the Haskell world, from the outside, are people who write technobabble Ph.D. theses which put _Star Trek_ episodes to shame; the sheer amount of polysyllabic post-graduate prose which gets dedicated to Haskell leads, not unreasonably, to outsiders concluding that they'll need to understand all that gunk before they can be productive in Haskell. If you want to do something about this, don't sit around and write snarky articles which preach to the choir; follow Simon Peyton-Jones' lead and start explaining useful Haskell terms in everyday language.", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 8, "author": "redditnoob", "created_utc": "1192681566", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "revence27", "created_utc": "1192689746", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 4, "author": "redditnoob", "created_utc": "1192713978", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c029w9d", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426112, "score": 0, "score_hidden": false, "body": "thanks.\n\nnow i know that there's at least one person on this site that knows something about programming.\n\ni wonder where most of these people work that they don't understand basic truths?\n\n", "author": "qwe1234", "created_utc": "1192726152", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 0, "parent_id": "t1_c029uui", "id": "c029w9d", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 4, "name": "t1_c029uui", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426130, "score_hidden": false, "body": "It isn't either/or. There are times when the computer's efficiency is much more important than how much programmer time is needed. I would argue there are many parts like this in most production software. It really matters, a lot, if you can serve the same number of web pages with 3 servers or 1. Users really do notice the difference between 0.5 seconds and 1, and their time is multiplied again and again.\n\nThis article appears naive and insulting for giving me a lecture denying this even exists. ", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029top", "id": "c029uui", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427426127, "subreddit_id": "t5_2fwo", "archived": true, "ups": 2, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 2, "id": "c029v66", "author": "sambo357", "created_utc": "1192717387", "distinguished": null, "edited": false, "body": "That argument is hypocritical.\n\n'&gt;&gt;' is 'more important than.\n\nMy efficiency &gt;&gt; my computers efficiency &gt;&gt; your efficiency.\n\nTherefore I will code in haskell but I want to use your libs and I prefer you write them in C for my computers efficiency.", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029v66", "parent_id": "t1_c029top", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c029top", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5yigz", "retrieved_on": 1427426145, "body": "You are supposed to care about efficiency. And the article doesn't say you shouldn't. But whose efficiency?\nYou can do a search over a terabyte of text in under one microsecond. But you won't do that, because it requires you to write the search in assembly, which doesn't consider _your_ efficiency.\n\nYour efficiency matters more than the computer's efficiency. That (and that alone) is the reason you don't code in assembly or write an efficient text editor on the ENIAC.\nWe live this truth, and yet continue to say otherwise. Our efficiency is The True Efficiency. :o)", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c029t5b", "id": "c029top", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02a2k3", "gilded": 0, "link_id": "t3_5yigz", "retrieved_on": 1427426030, "score": 0, "score_hidden": false, "body": "I agree. Haskell has many interesting features but performance is not among them.\r\n\r\nI'd much rather the Haskell community just admit that Haskell does not provide the same optimization potential as C++/OCaml etc., rather than pretend that performance is always unimportant.\r\n\r\nThey should either do that or optimize the Haskell implementations on the ray tracer language comparison...\r\n", "author": "jdh30", "created_utc": "1192803395", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 0, "parent_id": "t1_c029t5b", "id": "c02a2k3", "author_flair_css_class": null}], "subreddit": "programming", "ups": 8, "name": "t1_c029t5b", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5yigz", "retrieved_on": 1427426152, "score_hidden": false, "body": " This article completely lost me when it replied to concerns about efficiency with a big pretentious lecture that boils down to why I'm not supposed to care. Sorry, but yes it does matter. If I have a million entries in a database table, and I need to do something with them for a report, it really matters whether it takes one second or ten or one minute (or longer) using the same algorithm.\n\nWe'll just wait until hardware gets faster and they write better compilers. Okay, enjoy staring at that hourglass.\n\n_Only_ caring about performance, throwing away ease of development and maintenance, is really stupid, as everyone knows. But no matter what the effect on productivity, not caring at all about it is equally stupid, if not more. It's really not that hard for a happy programmer to produce slow and bloated software that is painful to use. In my opinion, there is plenty of preaching about this first point, and not nearly enough respect for the second.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t3_5yigz", "id": "c029t5b", "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427426117, "subreddit_id": "t5_2fwo", "archived": true, "ups": 2, "gilded": 0, "link_id": "t3_5yigz", "downs": 0, "score": 2, "id": "c029vx2", "author": "m4dc4p", "created_utc": "1192723414", "distinguished": null, "edited": false, "body": "Great read", "author_flair_text": null, "subreddit": "programming", "name": "t1_c029vx2", "parent_id": "t3_5yigz", "score_hidden": false, "author_flair_css_class": null}