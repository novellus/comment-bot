{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "malcontent", "created_utc": "1193022155", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "infinite", "created_utc": "1193123363", "children": [{"controversiality": 0, "retrieved_on": 1427425541, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02b49w", "gilded": 0, "link_id": "t3_5ys23", "downs": 0, "score": 2, "score_hidden": false, "body": " Of course, if you use a proxy, nothing prevents you from creating your own keyword, such as \"quickselect * from posts where threadid = ?\" and then have the proxy translate that in a normal select performed on the master.\n\nThe main problem I have found with using asynchronous replication, and one that I realize is not solved by MySQL-Proxy either, is that it leaks into the implementation of your application, precisely for the reason you mentioned.\n ", "author": "div", "created_utc": "1193259969", "distinguished": null, "edited": true, "author_flair_text": null, "subreddit": "programming", "ups": 2, "parent_id": "t1_c02aqqr", "id": "c02b49w", "author_flair_css_class": null}], "subreddit": "programming", "ups": 2, "name": "t1_c02aqqr", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ys23", "retrieved_on": 1427425718, "score_hidden": false, "id": "c02aqqr", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02ahny", "body": "Well this requires a synchronous cluster, something that isn't well supported in Postgres and the level of robustness of mysql synchronous clustering isn't clear to me yet. I think asynchronous replication is the way to go, it's simple and effective, but this proxy wouldn't work. If you write to the master then it might take 10 seconds to propagate writes to the slaves.\r\n\r\n\r\nWhat you could do is write your application s.t. it by default reads from any slave, but as soon as it writes, it uses the master for reading for 10-20 seconds, after that it can start using the slaves. The reason is: when a user adds/modifies the database, the user expects to see that change. So record the notion of when the user last modified the DB and route requests accordingly, that sounds like a sane, scalable approach.\r\n\r\n\r\n\r\nI want to believe you can throw a synchronous mysql cluster at a problem and solve it, but I need cold hard proof before I believe that. ", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02ahny", "controversiality": 0, "archived": true, "link_id": "t3_5ys23", "retrieved_on": 1427425834, "score_hidden": false, "id": "c02ahny", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5ys23", "body": "Let's hope someone ports it to postgres soon.\n", "author_flair_css_class": null}