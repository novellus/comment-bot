{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192624567", "ups": 1, "gilded": 0, "link_id": "t3_5yhra", "retrieved_on": 1427426228, "score": 1, "body": "[deleted]", "id": "c029naq", "author": "[deleted]", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029naq", "parent_id": "t3_5yhra", "score_hidden": false, "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "bcorfman", "created_utc": "1192628181", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "w-g", "created_utc": "1192628698", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1192633990", "ups": 3, "gilded": 0, "link_id": "t3_5yhra", "retrieved_on": 1427426218, "score": 3, "body": "&gt; But a red-black tree is not a B-tree.\n\nIt is, kind of. A red-black tree is an [isometry of 2-3-4 trees](http://en.wikipedia.org/wiki/Red_black_tree#Uses_and_advantages) using distinguished binary nodes. [These](http://en.wikipedia.org/wiki/2-3-4_tree), in turn, are a specialization of B-trees (they're B-trees of order 4).", "author": "notfancy", "author_flair_text": null, "distinguished": null, "edited": false, "id": "c029o3n", "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c029o3n", "parent_id": "t1_c029nl5", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c029nl5", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 3, "link_id": "t3_5yhra", "retrieved_on": 1427426224, "body": " &gt; red-black tree ... (which is a B-tree variant already)\n\nActually, both B-trees and red-black trees are two different specialized binary search trees. But a red-black tree is *not* a B-tree.\n\nYou can check the definitions of both at Wikipedia.\n\nAlso, don't count on \"O(1)\" being always lightning fast. You'd need a *very* good hash table for that, and even then, there's a hidden constant in that O(1). (Remember that O(1) is the same as O(1000000)).\n\nAnd finally: you don't traverse a hash_map in the order defined by your keys. You can walk a B-tree or a red-black tree in the right order easily and quickly.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c029njq", "id": "c029nl5", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "archived": true, "link_id": "t3_5yhra", "retrieved_on": 1427426225, "id": "c029njq", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c029njq", "parent_id": "t3_5yhra", "body": "So where are the benchmarks on how it's \"much faster\" than the standard STL red-black tree implementation (which is a B-tree variant already)? I couldn't find much useful info in the Wikipedia links. Even if it wins on insertion speed, it's going to be hard to beat the O(1) retrieval on a hash_map.", "author_flair_css_class": null}