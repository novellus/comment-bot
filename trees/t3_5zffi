{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 34, "author": "novagenesis", "created_utc": "1193749186", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 14, "author": "revence27", "created_utc": "1193750365", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 8, "author": "novagenesis", "created_utc": "1193755629", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "robbie", "created_utc": "1193757867", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "novagenesis", "created_utc": "1193758426", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "revence27", "created_utc": "1193759845", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193761651", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "revence27", "created_utc": "1193762716", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193763718", "name": "t1_c02c6o1", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424973, "score": 2, "score_hidden": false, "id": "c02c6o1", "author": "novagenesis", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 2, "parent_id": "t1_c02c6jd", "body": "Makes sense... I would really like to see cross-language library interfaces...imperative and functional, for example..maybe even stack-based (why not...)..\n\nMaybe even a nice design pattern that automates a some of that.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 3, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424975, "id": "c02c6jd", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c6jd", "parent_id": "t1_c02c6er", "body": "F# is Caml with objects done differently from how OCaml did them.\nIf you write OCaml _sans_ objects, that is portable to F#. The object thing is what is very different.\n\nAnd, on .NET, the libs are very imperative, so you should be ready to use F# only where you are creating the parts that feel better when written in a mainly functional style.\n\nBut I tell you it is a nice thing, F#, for .NET programmers who like simplicity. It tries hard and succeeds for the most part.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424976, "id": "c02c6er", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c6er", "parent_id": "t1_c02c666", "body": "Hot...ok.  I promise to be open-minded and give OCaml another test.\n\n\nAnother question... how does OCaml compare with F#?", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c666", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 3, "link_id": "t3_5zffi", "retrieved_on": 1427424979, "body": "OCaml compiles to ELF, yes.\n\nI hate the syntax, too, but hey. The bugger is faster than C++, without requiring a megabyte of `&lt;...&gt;` in order to implement a generic function. ;o)", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c5zq", "id": "c02c666", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "gnuvince", "created_utc": "1193761198", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193762988", "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424974, "score": 1, "score_hidden": false, "id": "c02c6kp", "author": "novagenesis", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02c6kp", "parent_id": "t1_c02c6cf", "body": "Yeah, but I mean, do they compile to .o files?  Can I link them statically against a piece of C code, with (or preferably without) a type-conversion interface?", "author_flair_css_class": null}], "subreddit": "programming", "ups": 3, "name": "t1_c02c6cf", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424977, "score_hidden": false, "id": "c02c6cf", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5zq", "body": "Yes, O'Caml has two compilers: ocamlc compiles to byte-code, ocamlopt compiles to native code.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 2, "name": "t1_c02c5zq", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424983, "score_hidden": false, "body": "I hated the syntax...but after banging my head into Haskell's monad tutorials a few dozen times and coming out with little more than a headache (though I never checked out the premade State monad), I might give ocaml another try at that.\n\nDoes it have a compiler to elf format?", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c5xg", "id": "c02c5zq", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424983, "id": "c02c5xg", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c5xg", "parent_id": "t1_c02c5pm", "body": "&gt;&gt; I don't care about the details of lambda calculus, for example, but I like coding in a functional style...until I have to jump through hoops whenever I want to utilize variables, states, etc.\n\nyou might like ocaml", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "LaurieCheers", "created_utc": "1193760066", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "novagenesis", "created_utc": "1193762245", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "gwern", "created_utc": "1193768149", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193770192", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "gwern", "created_utc": "1193780698", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424934, "score": 1, "body": "It's true... sine you'd probably design the language block-by-block in macro, you simply define those blocks non-forcing..only force when you hit a force.", "id": "c02c9n1", "author": "novagenesis", "created_utc": "1193787691", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02c9n1", "parent_id": "t1_c02c8rz", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424946, "body": "As far as 1 goes, laziness can be subtler than that. For example, I understand C's ternary operator is lazy (or \"short circuits\"), but you can't write your own ternary operator easily. That doesn't involve infinite datastructures at all, just control structures and evaluation thereof.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c8rz", "parent_id": "t1_c02c7ix", "id": "c02c8rz", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c7ix", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424962, "body": "So true...but there's two solutions to that.\n\n1) Your fault... if someone utilizes a Haskell infinite list in C, whoops, it does exactly as asked and starts evaluating it.  Give some bounds checking capability for that.\n\n2) Allow functions to be declared \"laziness required\", and waterfall like 'const' does in C++... include infinite sets in that functionality.\n\nBoth seem doable.  You don't have to guarantee the languages will always play nice, just interface and document how the differences will play out between them.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c7an", "id": "c02c7ix", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c7je", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424962, "score": 1, "score_hidden": false, "id": "c02c7je", "author": "novagenesis", "created_utc": "1193770307", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02c7an", "body": "Or to put it differently... the \"sure\" means you can theoretically implement a preprocessor that'll convert any amount of inline C code into working Haskell code... in some way, shape, or form (maybe?, maybe not)", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424966, "body": "\"You can make any amount of Haskell code non-lazy if you want, right?\"\n\nSure, but then you might get non-termination. That was sort of the point of lazyness - more programs will terminate when evaluated lazily than will when strict (ie. every strict program will obviously work as a lazy program, but a lot of lazy programs will require rewriting before they will work strictly).", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c7an", "parent_id": "t1_c02c6h8", "id": "c02c7an", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424975, "id": "c02c6h8", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c6h8", "parent_id": "t1_c02c675", "body": "&gt;I imagine merging them all together with a \"meta-language\" which allows you to switch from language to language, even in the middle of a function\n\nWe've all dreamed of that.  A language that consists entirely of robust macros would achieve this ... except\n\n&gt;different languages have different concepts of what a number is, what a list is, etc\n\nBingo...In this meta-language you'd have to re-invent each language to use a very specific typeset...\n\nof course, if you compiled to a language like .NET (which I understand to be something like an object oriented assembly), you simply need to generate a standard and hooks for export.  Bignum would need a \"to_int\" which can pass some sort of exception.  True_decimal (few if any languages use it, but hey) would need a \"to_float\"... lists would need a standard back-end infrastructure...\n\nI've never been concerned with infrastructure in compiler design as much as interface.  If you can design the interface behavior deterministically, the infrastructure *must* be possible, even if the interface allows you to fully implement every major language in a macro context.  \n\nOf course, it's about as complex a project as a near-perfect halting machine that can give an \"I don't know\" to the 1% it fails on with a 100% chance itself of halting itself...doable? yes... nontrivial?  That word doesn't even begin to describe it.\n\n&gt;to make laziness safe, Haskell relies on knowing everything that's going on\n\nBut that's actually fairly easy once you've built C on top of a macro-centric lazy language...  You just force at every step in the process within the definition of the C language.  You *can* make any amount of Haskell code non-lazy if you want, right?\n\n&gt;If there's a C program stampeding around, who knows what data might be needed at any given point?\n\nBecause the C program's definition explicitly evaluates everything that touches it at any time, lazy-be-damned.\n\nWith that alone I'm pretty certain...if the language front can be designed in a way that can macro-define all languages (a momentous project in and of itself), the infrastructure back end is guaranteed to follow.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424933, "score": 1, "body": "Take a look at http://www.mozart-oz.org/\n\nThey do multiparadigm based on a simple base language. Dataflow, logic, functional, procedural, object-oriented, it's got all the fun widgets, and ultra-cheap threading and concurrency, too.", "id": "c02c9rs", "author": "jaggederest", "created_utc": "1193789146", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02c9rs", "parent_id": "t1_c02c675", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "ups": 2, "name": "t1_c02c675", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424979, "score_hidden": false, "id": "c02c675", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c02c5pm", "body": "&gt; If every language compiled to .NET,\r\n&gt; and .NET was able to implement fast\r\n&gt; algorithms using C somehow, then that\r\n&gt; would work, too.\r\n\r\nOh, man, this is a beautiful idea. I imagine merging them all together with a \"meta-language\" which allows you to switch from language to language, even in the middle of a function (maybe - although that's probably very hard to implement and not especially useful), so you can use whatever is best at doing the job at hand.\r\n\r\nThere would be some challenges with it, though - different languages have different concepts of what a number is, what a list is, etc; there might end up being a lot of translation code to convert from one language's format to another. And then there's the problem that to make laziness safe, Haskell relies on knowing everything that's going on. If there's a C program stampeding around, who knows what data might be needed at any given point?", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "jimbokun", "created_utc": "1193760682", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193762724", "ups": 4, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424975, "score": 4, "score_hidden": false, "id": "c02c6je", "author": "novagenesis", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02c6je", "parent_id": "t1_c02c69t", "body": "&gt;Where does Common Lisp fail you?\n\nGod..I was afraid someone would jump me for that... Here's a few things:\n\n1 ELF Compliance. \n\n2 LISP is not the *best* syntax for a lot of things.  Due to #1, it's not easy to use the language that is best at those things.\n\n3 Native Code compilation in Windows is ugly...and even then, it pushes you to use a style that almost requires a JIT overlay, an added piece of back-end complexity I don't always want to use\n\n4 Its libraries, while very many, are not very standard.\n\n\n&gt;Common Lisp supports a broader range of programming styles than any other programming language\n\nSure... but all the best perks of any of those styles is nowhere to be found in Common Lisp.  I like pattern matching.  I like nice easy array access (the list isn't always the best tool for the job).  I'll be honest, Common Lisp is one of my favorite languages...that's why I brought it up at all.  But it's not perfect, and until I see Common Lisp fully implemented for .NET (and I hate .NET...), it's a gorgeous desert island with a kludgy FFI.\n\n&gt; I think CL's problems lie in the realm of the community and libraries being fractured between competing implementations and other social issues.\n\nYeah... that, too...though the lack of standardization requires me to google libraries in the first place, which means they're not at my fingertips anyway.\n", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "[deleted]", "created_utc": "1193778499", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "jaggederest", "created_utc": "1193789213", "children": [{"distinguished": null, "controversiality": 0, "retrieved_on": 1427424885, "subreddit_id": "t5_2fwo", "created_utc": "1193843806", "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "id": "c02cdht", "author": "[deleted]", "archived": true, "author_flair_text": null, "edited": false, "body": "OK, I'll bite: like what?", "subreddit": "programming", "name": "t1_c02cdht", "parent_id": "t1_c02c9s2", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424933, "body": "I love Oz, I just wish I could use it for more practical things.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c9s2", "parent_id": "t1_c02c8ju", "id": "c02c9s2", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424948, "id": "c02c8ju", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c8ju", "parent_id": "t1_c02c69t", "body": "\"I would say that, bottom line, Common Lisp supports a broader range of programming styles than any other programming language.\"\n\nThen you need to check out [Oz](http://www.mozart-oz.org). In particular, you need to read [Concepts, Techniques, and Models of Computer Programming](http://www.info.ucl.ac.be/~pvr/book.html), which is, IMHO, the successor to \"Structure and Interpretation of Computer Programs,\" while doing so. :-)", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424978, "body": "\"Everyone who embraces Common Lisp instead is taking on yet another set of major limitations...\"\n\nWhere does Common Lisp fail you?  You say you want imperative, functional and object oriented programming styles.  CL is good at all of these.  It nudges you towards functional over imperative where possible, but generally that's a good thing.  It is not as \"too the metal\" as C, but it has native code compilers that make pretty fast code.\n\nI would say that, bottom line, Common Lisp supports a broader range of programming styles than any other programming language.  I think CL's problems lie in the realm of the community and libraries being fractured between competing implementations and other social issues.  Are those the limitations of which you speak?", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c69t", "parent_id": "t1_c02c5pm", "id": "c02c69t", "author_flair_css_class": null}], "subreddit": "programming", "ups": 8, "name": "t1_c02c5pm", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424985, "score_hidden": false, "body": "Then we both have to leave our homelands.\n\nA quick summary of the below splurge... To fix these issues, we have a few huge needs.\n\n1) Some sort of integration that lets us use languages like a 'toolbox' instead of a bunch of separate toys.  I want to do imperative programming in C and deal with lists in a functional Haskell...only to return the list to C when I'm done.\n\n2) A more positive attitude towards \"new\", with a respect towards \"old\".  Everyone who laughs at C and embraces Haskell is throwing out one set of limitations for another.  Everyone who embraces Common Lisp instead is taking on yet another set of major limitations (major enough to keep Lisp from becoming my primary language, as much as I love the syntax)\n\n3) A language or languages that allow such self-manipulation that you can implement features this core on the fly\n\nI'm really getting into compiler design myself because I find features on a daily basis that I feel belong in a language that are either in NO languages at all, or are in languages that have \"features\" that paralyze my programming style.\n\nI don't care about the details of lambda calculus, for example, but I like coding in a functional style...until I have to jump through hoops whenever I want to utilize variables, states, etc.\n\nI hate string-formation in C (have to either prepare a buffer or allocate memory manually to merge strings), but I otherwise love the 'to the metal' directness and speed of it.\n\nI simply can't stand object-oriented programming as a rule, and think that the idea of organizing a program as a series of objects is a serious waste of time and infrastructure... but I think having AN object somewhere in code can be really useful.  One or two \"self-aware\" recordsets in an ocean of otherwise imperative or functional code.\n\nI think closures are holy, but I've never seen an \"each\" that handles lookahead or lookbehind... Imagine something like this:\n\ndef fib(x): map(x; first?1 , second?1 , else? x + prev)\n\n\nLanguages have a lot of growing to do, but I think the biggest problem is finding a clean centralized way to merge them...  If every major language compiled to the elf standard, then any well-documented code could be accepted by a progressive company, allowing for language growth.\n\nIf every language compiled to .NET, and .NET was able to implement fast algorithms using C somehow, then that would work, too.\n\nedit(mod of test code for fib)", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c56a", "id": "c02c5pm", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c02c56a", "controversiality": 0, "author_flair_text": null, "ups": 14, "link_id": "t3_5zffi", "retrieved_on": 1427424992, "body": "Very pertinent points. Upmodded.\n\nHowever, can we fix these issues with the simple languages unless we are willing to outgrow the obviously-broken non-simple languages?\n\nThe men who conquered had to leave their homelands and go out to the uncharted sea - there be dragons.\nProgress will, at the very least, have to cost us these comforts like extant libraries.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c530", "id": "c02c56a", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "arnoooooo", "created_utc": "1193751131", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 7, "author": "novagenesis", "created_utc": "1193754090", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "OMouse", "created_utc": "1193772154", "children": [{"controversiality": 0, "retrieved_on": 1427424958, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c7th", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 2, "score_hidden": false, "id": "c02c7th", "author": "novagenesis", "created_utc": "1193773027", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 2, "parent_id": "t1_c02c7qr", "body": "I agree 100%.  That's the whole point.  Everything is designed for C/C++.  If you can't cleanly interface with it, it's crap.\n\nAs I said elsewhere, someone needs to make a design pattern for interfaces for libraries that cross different language styles.  Of course, I think that'd start by a good definition as to how to port some mission-critical libraries like OpenGL", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c7qr", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424960, "body": "&gt;The very idea of using OpenGL or Direct3d in Haskell gives me headaches.\n\nIt may be because those APIs were designed for C/C++ which are quite different languages than Haskell. What if the API was re-designed by a person who mainly uses Haskell? Do you think that would make a difference?", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c5jt", "id": "c02c7qr", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 7, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "id": "c02c5jt", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c5jt", "parent_id": "t1_c02c58x", "body": "Just hope to god the functionality you want is already there... Because it's a nightmare to *find* that functionality in a library.\n\nThe very idea of using OpenGL or Direct3d in Haskell gives me headaches.\n\nMost libraries do not provide \"core language functionality\"... they provide 'special' functionality.  You do not get the entire Boost library in Haskell, nor does most of that library become trivial.\n\nMulti-arrays, for example, are a bitch in Haskell in my experience.  Creating a simple interface to multi-arrays is a project in and of itself...or an #include statement.\n\nIn return, Boost creates much of the desired functionality in these \"simple\" languages.\n\nFor example...the holy \"closure\" implemented in C++: http://www.boost.org/libs/spirit/doc/closures.html\n\nHaving not used Boost much, I'm not sure if it works up to the hype, but hey...\n\nMind you, I'm not fond of using object-oriented wrappers to implement features, but it's better than having features that are almost impossible to implement at all.\n\n", "author_flair_css_class": null}], "subreddit": "programming", "ups": 3, "name": "t1_c02c58x", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424991, "score_hidden": false, "id": "c02c58x", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c530", "body": "One thing to bear in mind though is that you need libraries a lot less with a \"simple\" language than with a \"not simple\" one. And the few available libraries for \"simple\" languages are usually simpler and better.", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c530", "ups": 34, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424993, "score_hidden": false, "body": "...the one thing left out is how if you give up the \"not simple\" languages, you lose \"SIMPLE\" access to the largest library collection in the world... and that's not *simple* either\n\nAlso, variables and state aren't *simple* in a purely functional language.\n\n...and lists aren't simple when you have to deal with memory management when you're regularly accessing arbitrary elements of a structure, doubly so when it may be sparse (it may take offsets between 1 and 64000, but you might only use 1/4 of those...in an array that's all constant time).  Why aren't they simple?  Because you have to do something really complicated to drop the O notation for certain programs to run in a few seconds instead of a few hours.\n\nThat's my experience with 'simple' languages.  If I want to do something easy, it's 'simple'.  If I want to hit in a nail, the screwdriver doesn't work.  I want to get better at those, but at the moment, I don't see any simple way in Haskell to deal with an object that resizes regularly (you can trivially buffer with an array) or reduces random access time.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "id": "c02c530", "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427424993, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02c53e", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "score_hidden": false, "id": "c02c53e", "author": "[deleted]", "created_utc": "1193749348", "distinguished": null, "edited": true, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t3_5zffi", "body": "[deleted]", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 68, "author": "LaurieCheers", "created_utc": "1193750895", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 8, "author": "revence27", "created_utc": "1193751506", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 15, "author": "TheManWithNoName", "created_utc": "1193753292", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "revence27", "created_utc": "1193754011", "children": [{"controversiality": 0, "retrieved_on": 1427424987, "subreddit_id": "t5_2fwo", "created_utc": "1193754609", "ups": 8, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 8, "id": "c02c5lp", "author": "novagenesis", "archived": true, "distinguished": null, "edited": false, "body": "But they *are* mutually-exclusive today because the US Mail Service doesn't currently take Haskell stamps...  you'd have to build a stamper in Haskell that makes the stamp look like C.", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02c5lp", "parent_id": "t1_c02c5jh", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c02c5jh", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "score_hidden": false, "id": "c02c5jh", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5gv", "body": "&gt; So that's an argument for using languages with rich library support, not for using languages with first class functions etc.\n\nThese two, libs and first class functions, are not mutually-exclusive.", "author_flair_css_class": null}], "subreddit": "programming", "ups": 15, "name": "t1_c02c5gv", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424989, "score_hidden": false, "id": "c02c5gv", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5aa", "body": "Sending the letter via the postal service is like calling a library function rather than implementing the postal service feature yourself by walking it there.  So that's an argument for using languages with rich library support, not for using languages with first class functions etc.  \n", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 8, "author": "mooli", "created_utc": "1193754296", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 7, "author": "mooli", "created_utc": "1193755519", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 7, "author": "novagenesis", "created_utc": "1193756661", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 10, "author": "earthboundkid", "created_utc": "1193770737", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1193770842", "ups": 3, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424961, "score": 3, "body": "Sure would... but you always have to implement a compiler in another language before you can bootstrap it for the first time against itself......", "id": "c02c7lv", "author": "novagenesis", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "name": "t1_c02c7lv", "parent_id": "t1_c02c7lb", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424925, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02cach", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 3, "score_hidden": false, "body": "If what I *want to do* is to write a compiler that will do what I *want to do*, then, well ...", "author": "Rofl_Waffler", "created_utc": "1193796199", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 3, "parent_id": "t1_c02c7lb", "id": "c02cach", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c7lb", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 10, "link_id": "t3_5zffi", "retrieved_on": 1427424961, "body": "&gt;Of course, the compiler for that language would be infinitely complex. It is an impossible language. \n\nWell, you just need to break down the problem. First, make a language called g with the following syntax:\n\n    //pre: Programmer knows what kind of language he wants to program in\n    //post: A compiler for that language is built\n    g;\n\nFrom there, it should be relatively simple to bootstrap in an f compiler. ", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c5tc", "id": "c02c7lb", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c5tc", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 7, "link_id": "t3_5zffi", "retrieved_on": 1427424984, "id": "c02c5tc", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5oy", "body": "It's really about *language* simplicity.\n\nThe ideal simplest *language* would have one command \"f\" that had the following pre-postconditions:\n\n    //pre: Programmer knows what he wants\n    //post: Does the what the programmer wants quickly and efficiently\n    f;\n\nOf course, the compiler for that language would be infinitely complex.  It is an impossible language.  On the other side of the coin, the most complex reasonable language is machine code (we're going to leave out obfuscated languages).  You write binary values in a hex editor.  The compiler for machine code is infinitely simple (there isn't one).\n\nAll other languages are somewhere in between.  Simpler compilers are more easily optimized and less bug-prone.  Simpler languages are more easily coded, usually less customizable, and as a whole less bug-prone.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 7, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424985, "id": "c02c5oy", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c5oy", "parent_id": "t1_c02c5kg", "body": "Answering myself here - the article really is very much more about simplicity at the point of interface, rather than simplicity as a whole, and the arguments are all over the place. On the one hand insisting that you should use the features and constructs available to make your code as simple and readable as possible, while lambasting languages like Java for providing a wealth of APIs to do exactly that.\n\nFrankly, its all a bit \"my language's one-liners are better than yours\", which does nothing for anybody.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 8, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "id": "c02c5kg", "author_flair_text": null, "distinguished": null, "edited": true, "name": "t1_c02c5kg", "parent_id": "t1_c02c5aa", "body": "Interesting, and I would disagree wholeheartedly that it is wrong.\n\nThey add a vast amount of complexity, in order to present a simple interface.\n\nStarting out with a blank slate and making some blind assumptions (ie. you can actually make it to china without dropping dead) it really doesn't get much simpler than pointing your feet in roughly the right direction and starting to walk.\n\nStarting out with a blank slate, it is a massive undertaking to implement a postal service that can deliver globally, while presenting a deceptively simple interface to the end user. Even starting with the infrastructure in place, the number of collaborators, the scheduling, the coordination behind the scenes - that's a far more complex piece of orchestration than a single person walking (and swimming) until they arrive.\n\nThe point the parent was making was the second solution is correct more because it leverages existing complexity, rather than reinventing a solution in a braindead fashion.\n\nFor another trivial example that pokes gaping holes in the article - the simplest way of finding an element in a sorted list is to just step through, one at a time testing each element until you locate it. Now, that is simpler than conducting a binary search isn't it? But which is more correct? Especially given that, whatever the language, there will doubtless be a prexisting function to do the hard work for you. Which brings us back to using a postal service (pre-existing, efficient, simple to use but complex behind the scenes) rather than walking to china.\n\n", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 8, "name": "t1_c02c5aa", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424991, "score_hidden": false, "body": "The post agents exist for a reason. They don't add complexity. They add simplicity. They have the system set out for the trip to China and back with the risks reduced to a minimum.\n\nThat's simplicity. Non-simplicity is where you are your own post agent (much like a language with no functions, for example).\n\nWell done for not thinking this through. I'll upmod you, however, because you make an interesting point, even though I think it is wrong. Interesting, but wrong (I'm sure many others are thinking even as you do).", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c587", "id": "c02c5aa", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 15, "author": "bcorfman", "created_utc": "1193752176", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 20, "author": "[deleted]", "created_utc": "1193755272", "children": [{"controversiality": 0, "retrieved_on": 1427424981, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02c622", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 6, "score_hidden": false, "id": "c02c622", "author": "lothair", "created_utc": "1193758986", "distinguished": null, "edited": true, "author_flair_text": null, "subreddit": "programming", "ups": 6, "parent_id": "t1_c02c5o6", "body": "Which is the point of programming languages.\n\nHowever, you still need to know what the post office does, and once you start to optimize (think air mail vs normal), you should know how it is done.\n\nWhich is why I'd would build me an airplane, if i had to sent A LOT of letters to china.", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424971, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c6vs", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 3, "score_hidden": false, "body": "Or how much we can treat as abstractions, without really working on them.", "author": "[deleted]", "created_utc": "1193765362", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 3, "parent_id": "t1_c02c5o6", "id": "c02c6vs", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c5o6", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 20, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "body": "&gt;Sending a letter starts looking a lot simpler to me.\n\nBingo. It's not what is actually the simplest solution, it's how you hide the complexity.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c5cp", "id": "c02c5o6", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c5cp", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 15, "link_id": "t3_5zffi", "retrieved_on": 1427424990, "id": "c02c5cp", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c587", "body": "Walking to China (especially depending on your starting continent) would also require a good deal of other actions (packing, planning, transportation, money, food, shelter, clothing). \r\n\r\nSending a letter starts looking a lot simpler to me.", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 36, "author": "LaurieCheers", "created_utc": "1193753074", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 10, "author": "revence27", "created_utc": "1193753918", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193754032", "name": "t1_c02c5jk", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "score": 5, "score_hidden": false, "body": "Ok, I'd agree with you there.", "author": "LaurieCheers", "author_flair_text": null, "distinguished": null, "edited": true, "archived": true, "subreddit_id": "t5_2fwo", "ups": 5, "parent_id": "t1_c02c5j1", "id": "c02c5jk", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "ups": 2, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "score": 2, "body": "Yeah..agreed...I'd love to see trivial list structures in languages like C.  It really wouldn't make compiling much more complex than it already is, nor would it slow down runtime.  All it would do is give a slight increase to footprint (which you can always have a #pragma to refuse)", "id": "c02c5l9", "author": "novagenesis", "created_utc": "1193754505", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02c5l9", "parent_id": "t1_c02c5j1", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424953, "subreddit_id": "t5_2fwo", "created_utc": "1193775646", "ups": 5, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 5, "body": "*...that arrays are favoured. As though they are the be-all of data structures.*\n\nI have used Java for many years and I haven't encountered one person who said this or coded as if he believed such a thing. You might find that in first-year programming classes, I don't know...", "author": "mynameishere", "archived": true, "distinguished": null, "edited": true, "id": "c02c868", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02c868", "parent_id": "t1_c02c5j1", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 10, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424989, "id": "c02c5j1", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c5j1", "parent_id": "t1_c02c5fy", "body": "Correct. I wish, though, that arrays weren't pushed down people's throats. There is sugar in Java, for example, to create an array.\nThe result is that arrays are favoured. As though they are the be-all of data structures.\n\nIndeed, I think lists are better as a default data structure.", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "MarshallBanana", "created_utc": "1193754061", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "revence27", "created_utc": "1193755124", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "novagenesis", "created_utc": "1193756188", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 4, "author": "revence27", "created_utc": "1193756799", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "novagenesis", "created_utc": "1193758024", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c65y", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424979, "score": 1, "score_hidden": false, "body": "The vector is not the array. It is just like a list whose some parts are arrays.\n\nAnd yes, it is good if the compiler turns the list into an array, so that it presents you with a _simple_ interface to the belly of the beast. And that is a Good Thing.\nIt's usually called abstraction.\n\nAlso, when you need 2D arrays (I know you meant lists) in Haskell, use the cleaner option: recursive algebraic data types. It's simpler that way than the bug-bag called 2D arrays, isn't it? Mainly because it is verified by the type-checker.", "author": "revence27", "created_utc": "1193759802", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02c5y7", "id": "c02c65y", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 3, "name": "t1_c02c5y7", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424983, "score_hidden": false, "body": "&gt; Big-Oh notation is very misleading. There are many cases where C/Java/C#/C++/et al users use arrays (because there is sugar for them) when they shouldn't. Like when the array is short\n\nAt that scale, it really doesn't matter at all.  Arrays are easier to use in those languages.  Build a static array 20 elements long (just in case you have a little 'resizing'), and just use it.  You reduce allocation calls to *zero* over the entire app.\n\n&gt; More-importantly, you'll probably never use a list. Most compilers use (cleverly-managed) vectors where they present a list.\n\nA vector === an array.  So you're saying \"use a list because most compilers are smart enough to turn them into arrays if that's more efficient\" (which I guarantee isn't going to be 100% accurate).  \n\n&gt; And I generally don't care about speed. It is often how fast I'll hit the bug, rather than how fast the program will run. I'm ready to settle for a slightly-slower routine (especially on this here machine) with no bugs.\n\nI generally don't care about speed either.  You were talking about lists vs arrays.  They really are structures that are equally abstractable (you can generate the same function set for both) and have comparable cross-usability.  The only really solid difference is that you cannot build a true list entirely at compile time.\n\nOh, and about bugs...I'd rather hit a bug than a language limitation.  That is, I'd rather deal with a bug in a pointer-to-pointer than try to find an elegant way to handle 2d arrays in Haskell.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c5tt", "id": "c02c5y7", "author_flair_css_class": null}], "subreddit": "programming", "ups": 4, "name": "t1_c02c5tt", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424984, "score_hidden": false, "body": "Big-Oh notation is very misleading. There are many cases where C/Java/C#/C++/et al users use arrays (because there is sugar for them) when they shouldn't. Like when the array is short (two, three, four elements). In that case, O(n^2) is negligible. They gain the hit of using the array, and yet there is nearly no speed-up over the list equivalents (which are cleaner, safer, simpler).\n\nMore-importantly, you'll probably never use a list. Most compilers use (cleverly-managed) vectors where they present a list. Hence why list performance can be as fast as arrays very often.\n\nAnd I generally don't care about speed. It is often how fast I'll hit the bug, rather than how fast the program will run. I'm ready to settle for a slightly-slower routine (especially on this here machine) with no bugs.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c5rh", "id": "c02c5tt", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "MarshallBanana", "created_utc": "1193757317", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "ups": 3, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424983, "score": 3, "body": "Still don't matter... allocating memory log(n) times (if I recall, arrays allocate O(log n) if you double them every time they hit limits, and those limits are regularly hit) is going to be *orders* faster than allocating memory n times.\n\nAnd again, you can reduce allocation to 0 with sufficient space with most arrays.  Which is guaranteed to be faster.", "author": "novagenesis", "created_utc": "1193758325", "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02c5za", "parent_id": "t1_c02c5va", "score_hidden": false, "id": "c02c5za"}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "gsg", "created_utc": "1193764314", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02c7en", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424964, "score": 1, "id": "c02c7en", "author": "MarshallBanana", "created_utc": "1193769065", "distinguished": null, "edited": true, "body": "Well, that copying would be O(1), so I ignored it. I'm also assuming that a smart allocator would avoid placing small allocations right after big ones for this reason.\n\nEdit: What, -3 for stating technical facts? What is *up* with the moderation in here? Did I upset some functional programmers or something?", "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02c6r1", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424972, "body": "&gt; resize an array without copying any of the data\n\nHow does this work in the general case? \n\nI can see how operating systems can use virtual memory to string together pages in any desired order, while preserving the flat address space that array implementations need. But there still might be non-array data after the terminal element in a given page, which would seem to require at least some copying.\n\nDo I have this wrong?", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c6r1", "parent_id": "t1_c02c5va", "id": "c02c6r1", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424984, "body": "&gt; Allocation - O(n)\n\nThe optimization you forget, that I mentioned earlier, is virtual memory. realloc() can resize an array without copying any of the data. Well, depending on implementation is might still technically be O(n), but there's such a huge constant factor involved that it might as well be O(1) in all practical cases.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c5va", "parent_id": "t1_c02c5rh", "id": "c02c5va", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "OneAndOnlySnob", "created_utc": "1193763884", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193765978", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "OneAndOnlySnob", "created_utc": "1193767861", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193769951", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "OneAndOnlySnob", "created_utc": "1193771292", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193772749", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "OneAndOnlySnob", "created_utc": "1193775800", "children": [{"controversiality": 0, "retrieved_on": 1427424935, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c9kl", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "score_hidden": false, "body": "&gt;but chess also isn't a high paced game that will be hurt from representing the board as a list either.\n\nSure..ok... 12 player online 4d (time can be a component, right?) tetris... Most serious 2d games also fall under the category if you want to get burdened by \"reality\", which I'm usually theoretical and stupid enough to avoid\n\n&gt;This really isn't about speed. It's about elegance and simplicity and avoiding opportunities for bugs to creep into software\n\nOne might say middle-inserting in an array is a design flaw, and thus a bug... Otherwise, it's all about having a bug-tested support kit, like stl's Vector class.  I hate C++, honestly, but the stl and Boost libraries can do almost anything (check out the closure class...)\n\n&gt;Lists in functional languages are basically unlimited length stacks in constant time. \n\nNothing is constant time about a list except car and cdr... unless it's converted into an array.  Since push and pop just require those two, it's constant time -except- with a higher overhead with lists (allocation vs not)... \n\nWhat it comes down to is that you can touch about the same time constants with both, but arrays have more you can do to drop to unexpected constant time... \n\n&gt;No, I'm afraid you made no point there. Many functional languages do have arrays, you know. We can implement fast quick sorts with them\n\nAs perlers say, TIMTOWTDI... My point is that there are right tools for the job, and the right tool isn't ALWAYS functional.  Using functional programming with procedural algorithms (especially if they use an array) just comes out ugly and slower\n\n&gt;I mean, 40 lines? That's not so bad at all.\n\nWorse than the 3 people use to represent a fake Sieve..the point is that people can actually believe the thing they did in 3 was the real sieve cuz it LOOKS similar.\n\n&gt;It's a delightful language that lets you get your imperative on when you want it.\n\nI'm planning to try it for those reasons..\n\nSomeone needs to right an optionally lazy, somewhat functional, C", "author": "novagenesis", "created_utc": "1193787210", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02c873", "id": "c02c9kl", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "score_hidden": false, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424953, "body": "&gt; There's millions of reasons. Chess pieces on a chessboard is one of them.\n\nA fine point, but chess also isn't a high paced game that will be hurt from representing the board as a list either.  Or a binary random access list.  Or an array!  Either way.\n\n&gt; The big thing, though, is that for most uses, an array can easily be made faster than a list with the exact same interface visible to the world. Middle insertion is about the only thing that cannot be made equal time or better than a list....\n\nActually, for middle insertion, even with a mutable list, you must still seek to the right location which means your worst case is still O(n), no matter what you do.  Immutable lists means you must also rebuild the portion of the list that comes before the insertion point.  This really isn't about speed.  It's about elegance and simplicity and avoiding opportunities for bugs to creep into software.  I really think immutable lists are a key to that.  Especially when used in combination with folds, filters, and maps.\n\nHowever, I still also posit that there are a variety of functional programming friendly data structures that are efficient when lists aren't up to the task.\n\n&gt; You can implement a limited-length stack in constant time with arrays.\n\nLists in functional languages are basically unlimited length stacks in constant time.  If you really wanted to limit the length of your stack, you could easily make a special type that counts how many items are in the stack and rejects items when it fills up.\n\n&gt; Yes, quicksort is not the best possible sort routine, but the argument has made its point.\n\nNo, I'm afraid you made no point there.  Many functional languages do have arrays, you know.  We can implement fast quick sorts with them.  We are just snooty and don't like them because they're not friendly with our functional programming ideals and prefer other sorting algorithms.\n\nAs for the sieve, I really don't see how using a priority queue would be so monstrous.  I mean, 40 lines?  That's not so bad at all.  40 lines in Java gets you to public static void main(string [] args) ;)\n\n&gt; Sure... I agree 100% and would love to utilize functional concepts in my everyday code... I still want my imperative programming and arrays.\n\nThen we're practically in agreement!  You should spend some time with Ocaml.  The whole + +. +/ thing is a little unfortunate, but it has its reasons and once you get past that, it's a delightful language that lets you get your imperative on when you want it.", "archived": true, "distinguished": null, "edited": true, "name": "t1_c02c873", "parent_id": "t1_c02c7sh", "id": "c02c873", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c7sh", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424958, "id": "c02c7sh", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c7nn", "body": "&gt;I don't think there are many \"good\" reasons to even do this in the first place. The reasons do exist, but they aren't that common\n\nThere's millions of reasons.  Chess pieces on a chessboard is one of them.  There are as many reasons you'd want to access item 'n' in a grouping as there are reasons you'd want to iterate across them.\n\n&gt;It's usually very beneficial to not use an array if possible.\n\nIn a functional language, sure.  Most of this thread is arguments for and against lists vs arrays.  The big thing, though, is that for most uses, an array can easily be made faster than a list with the exact same interface visible to the world.  Middle insertion is about the only thing that cannot be made equal time or better than a list. (and 9 times out of 10, I don't care about list order so I'll insert to the end).\n\n&gt;Quick sort is meant to be implemented with arrays. If you implement it with lists, of COURSE it's going to perform worse!\n\nBingo.  Some things are just better implemented with arrays.  You can implement a limited-length stack in constant time with arrays.  Yes, quicksort is not the best possible sort routine, but the argument has made its point.\n\nThe sieve was brought up because I recently read a thesis (which I can't find) showing that the most common sieve example is in-fact a reimplementation of the naive method.  The author produced a 40-line monstrosity to argue \"see, a sieve can be done well in haskell\".\n\n&gt;I just feel we have a lot to learn from functional programming\n\nSure... I agree 100% and would love to utilize functional concepts in my everyday code... I still want my imperative programming and arrays.\n\n", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424961, "body": "&gt; There's no \"good\" functional way to do random access in a long chain of objects.\n\nI don't think there are many \"good\" reasons to even do this in the first place.  The reasons do exist, but they aren't that common.  It's usually very beneficial to not use an array if possible.\n\n&gt; A trivial Haskell qsort ... \n\nLet me stop you right there.  Quick sort is meant to be implemented with arrays.  If you implement it with lists, of COURSE it's going to perform worse!  This is as true in C as it is in Haskell.  You'd be much better off using a heap sort with a priority queue or plain old merge sort.\n\n&gt; Ditto with the Sieve of Erastothenes.\n\nIIRC, the Sieve of Erastothenes involves checking each number in sequence against a list of the prime numbers you've already found.  For this, either use a queue with lazy evaluation to store the primes in, or a priority queue, in which you store the \"next\" multiple of each prime.  Such a solution would be both elegant and efficient.\n\n&gt; Try building a chess program (interface and AI) with save/load functionality and without implementing state once. (Monads imply a side-effect which is mutable...no?) It's more difficult than using a simple 2d array.\n\nWhile I honestly have no doubt that it could be done if you were determined enough, you are correct that state is sometimes the easiest way to go.  I just feel we have a lot to learn from functional programming.  We should study its principles and adapt them wherever it makes sense, because they're good principles!", "archived": true, "distinguished": null, "edited": true, "name": "t1_c02c7nn", "parent_id": "t1_c02c7i1", "id": "c02c7nn", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c02c7i1", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424962, "score_hidden": false, "id": "c02c7i1", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c790", "body": "&gt;Arrays can't be implemented with any reasonable efficiency in a functional way\n\nSure.  Functional programming isn't always the Best Way To Do It for a lot of things.  There's no \"good\" functional way to do random access in a long chain of objects.  Purely Functional languages already have the same limitation as lists.  A mostly functional language *could* have the best of both worlds.\n\n&gt;There is some sacrifice, but a whole class of unpredictable bugs that come about from sharing references to data disappears\n\nAnd a whole class of new unpredictable bugs that come about...except they're not often called bugs.  A trivial Haskell qsort attempted over a list of 1000000 will show what that is... unexpected side-effects of using the functional style that costs entire orders of O notation.  Ditto with the Sieve of Erastothenes.  These are overused examples, but the argument is strong.  You have to fix a design \"bug\" by reimplementing the code less elegantly.\n\n&gt;code also becomes easier to multithread, which is more and more important every year.\n\nTouche... but I think it's the headsman's response to dealing with variable sharing.  All variables in future systems should be declared as unshared or shared..and shared should include implicit locking.\n\n&gt;Immutability rocks!\n\nTry building a chess program (interface and AI) with save/load functionality and without implementing state once. (Monads imply a side-effect which is mutable...no?)  It's more difficult than using a simple 2d array.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02c790", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424966, "score_hidden": false, "body": "Arrays can't be implemented with any reasonable efficiency in a functional way.  To be functional, the data structure must be immutable.  If you change a value in an an array, you have changed the array itself.  To be functional, the method that sets the new value at the index should allocate a new copy of the array and return it.  That's a sucky idea.  \n\nHowever, with a list, the only thing you can REALLY do in a functional language is add a new node to the front.  Since the list is immutable, all the data from the old version of the list is reused as the tail for the new head node.  \n\nThere is some sacrifice, but a whole class of unpredictable bugs that come about from sharing references to data disappears, and code also becomes easier to multithread, which is more and more important every year.\n\nImmutability rocks!\n\nEDIT: I should add that arrays definitely have their place.  Lists don't make very good buffers for sockets or files.  However, I find cases where you're going to object[10] simply by index to be pretty rare.  Usually you're looking for something by key.  Anyway, if you need random access by arbitrary index, the functional data structure is the binary random access list.  It's a little bit weird, and frankly, not very useful, but it grows dynamically and gives O(log n) access by index.  Sure, it's not as good as an array, but again, can be made immutable, which I think is cool.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c6z9", "id": "c02c790", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c6z9", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424969, "id": "c02c6z9", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c6ok", "body": "&gt;Building a reverse list can be done using tail recursion and an accumulator for a very efficient O(n).\n\nTouche...though it adds O(n) space usage to do that.\n\n&gt;However, if you're doing a lot of random lookup, you probably want to use a self balancing binary search tree, which in this case neither lists nor arrays can compete with on simplicity and efficiency.\n\nAre you referring to key-based lookups?  Then you want to use a fully featured hash table.\n\nIf you're referring to object[10], then you definitely want to use an array for constant time (instead of logarithmic time).\n\n&gt;Plus, like lists and unlike arrays, BSTs can be implemented in a beautifully functional way, which appeals to me a great deal.\n\nIf you can't implement an array in a functional way, I blame the language.  You can easily recurse across the offset using a bounded array.  I'm not saying there's no point for lists, I'm saying they're not objectively better than arrays in every possible way.\n\n", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 2, "name": "t1_c02c6ok", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424973, "score_hidden": false, "id": "c02c6ok", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5rh", "body": "Reverse iteration on a singly linked list can be done using recursion in O(n) time very easily.  This is what fold_right does in functional languages.\n\nBuilding a reverse list can be done using tail recursion and an accumulator for a very efficient O(n).  This is what rev does in functional languages.\n\nHowever, if you're doing a lot of random lookup, you probably want to use a self balancing binary search tree, which in this case neither lists nor arrays can compete with on simplicity and efficiency.  Plus, like lists and unlike arrays, BSTs can be implemented in a beautifully functional way, which appeals to me a great deal.", "author_flair_css_class": null}], "subreddit": "programming", "ups": 2, "name": "t1_c02c5rh", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424985, "score_hidden": false, "body": "And arrays have added benefits that lists don't have.\n\nLists:\n\n    Allocation - O(1)\n    Iteration - O(1)\n    Reverse Iteration (singly linked) - O(n^2)\n    Reverse Iteration (doubly linked) - O(n) \n(at cost of space and complexity)\n\n    Random Lookup - O(n)\n    Deletion - O(1)\n\nArrays:\n\n    Allocation - O(n) \n(reducable through buffering to best-case zero-time, average case zero-time or O(1), theoretical worst case still O(n) but you need a functionally infinite growing list to hit that)\n\n    Iteration - O(n) \n(this is a faster order than lists because you can skip the step-up dereferencing)\n\n    Reverse Iteration - O(n)\n    Random Lookup - O(1)\n    Deletion - O(n) \n(This can be mitigated with a 'control value', and an array of objects that include a potentially empty value (like Data Types in Haskell, easily implemented in C) can reduce deletion to O(1) at the cost of slightly increasing the scale of the iteration)\n\nIn terms of speed (what most C programmers care about, honestly), the array crushes the list utterly.  How is the list better?  Simple, it's easier to implement dynamic length allocations, slightly easier to recurse over, and doesn't require contiguous memory.  You don't need to implement buffering or 'fake' deletion on the back-end.  This makes the under-the-hood \"simpler\" at the cost of language power.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c5np", "id": "c02c5rh", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424984, "subreddit_id": "t5_2fwo", "created_utc": "1193757061", "ups": 4, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 4, "body": "&gt; LaurieCheers was quoting the article, in the sentence you disagree with.\n\nYes, and that is exactly why I said \"as you quote\".", "id": "c02c5ul", "author": "MarshallBanana", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "name": "t1_c02c5ul", "parent_id": "t1_c02c5np", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c5np", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "body": "LaurieCheers was quoting the article, in the sentence you disagree with.\n\nStill, in a list-oriented language, lists are just as simple to deal with as arrays in an array-oriented language.\nAnd lists come with added benefits that arrays don't have.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c5jp", "id": "c02c5np", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 2, "name": "t1_c02c5jp", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "score_hidden": false, "body": "Not only is the argument presented completely moronic, the specific arguments are wrong, too. For instance, as you quote:\n\n&gt; Arrays have a problem. They cannot be resized, so any change to their dimensions is slow.\n\nWhich is not true at all under a modern virutal-memory system, where an array can be resized cheaply.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c5fy", "id": "c02c5jp", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 7, "author": "novagenesis", "created_utc": "1193754417", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 4, "author": "julesjacobs", "created_utc": "1193758517", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 5, "author": "novagenesis", "created_utc": "1193760090", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "julesjacobs", "created_utc": "1193762125", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "novagenesis", "created_utc": "1193763373", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "julesjacobs", "created_utc": "1193772811", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "novagenesis", "created_utc": "1193773555", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "julesjacobs", "created_utc": "1193782157", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193787959", "name": "t1_c02c9o5", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424934, "score": 1, "score_hidden": false, "id": "c02c9o5", "author": "novagenesis", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02c8z0", "body": "ooooooh...so an inverse tree type of pattern!\n\nSo if you did...\n\na = list(5,4,3,2,1)\nb = list(6,&amp;a[2])\n\nyou'd want to have:\n\na = [5,4,3,2,1]\nb = [6,3,2,1]\n\nand if you changed the 2, it'd change in both?\n\nwell that being a dynamic structure, you'd need to use something...I think a linked list would be a very dangerous choice, but sure..\n\nWhy would you want to do that now?", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c8z0", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424943, "body": "Oh, I see, the notation I used is confusing. The lists look like this:\r\n\r\n    a: cons(3,cons(2,cons(1,nil)))\r\n    b: cons(4,cons(1,nil))\r\n\r\nThe cons(1,nil) part is shared:\r\n\r\n    3 --&gt; 2 --&gt; 1 --&gt; nil\r\n               ^ \r\n          4 ---|\r\n\r\n(the thing on the right of the 4 is supposed to look like an arrow pointing at the 1)", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c7vp", "id": "c02c8z0", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424957, "body": "&gt;Stack *b = rest(a);\npush(3,a);\npush(4,b);\n// a: [1,2,3]\n// b: [1,4]\n\nThis is functionally impossible using a List in constant time... you're re-routing *next pointer.  '1' is a list node being pointed to.  The *next pointer on both cannot simultaneously link to the node with '2' and the node with '4', no matter what magic you use.\n\nAgain, impossible in constant time..you have to basically duplicate entire lists or you get invalid pointers showing up.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c7vp", "parent_id": "t1_c02c7so", "id": "c02c7vp", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c02c7so", "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_5zffi", "retrieved_on": 1427424958, "body": "An example:\r\n\r\n    Stack *a = newstack();\r\n    push(1,a);\r\n    push(2,a);\r\n    Stack *b = rest(a);\r\n    push(3,a);\r\n    push(4,b);\r\n    // a: [1,2,3]\r\n    // b: [1,4]\r\n\r\n&gt; If you want to pop an item and still keep it, then you have to duplicate that stack in any language, and that's never constant time.\r\n\r\nIt doesn't really depend on the language, but here's an example of a stack that you can pop and still keep the popped item, in constant time:\r\n\r\nGiven O(1) cons, car and cdr, and typedef List* Stack:\r\n\r\n    Stack* newstack(void)\r\n    {\r\n      Stack* s = (Stack*)malloc(sizeof(Stack*));\r\n      *s = NULL;\r\n      return s;\r\n    }\r\n    \r\n    void \r\n    push(int x, Stack* s)\r\n    {\r\n      *s = cons(x,*s);\r\n    }\r\n    \r\n    int\r\n    pop(Stack* s)\r\n    {\r\n      int r = car(*s);\r\n      *s = cdr(*s);\r\n      return r;\r\n    }\r\n    \r\n    Stack*\r\n    rest(Stack* s)\r\n    {\r\n      Stack* r = newstack();\r\n      *r = cdr(*s);\r\n      return r;\r\n    }\r\n\r\nI don't know if they work, but I'm fairly sure that this idea works. Oh, and you need a garbage collector ;)\r\n\r\nWith this implementation you don't get O(1) random access. Is it possible to make a stack with rest() *and* (amortized) O(1) random access?", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c6mc", "id": "c02c7so", "author_flair_css_class": null}], "subreddit": "programming", "ups": 2, "name": "t1_c02c6mc", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424973, "score_hidden": false, "body": "It works fine if you add elements to the array.  It *has* to be destructive, though... Of course, I would define a pop as a destructive operation by default.\n\nBeyond that, I gotta say I'm not sure what you want.  Do you want to be able to pop 10 items, push 10 items, and magically have access to the 10 popped items with a wave of the hand?  I'm just fine with overwriting the original (which is just an immediate or a pointer anyway...just be careful on memory management of pointers).\n\nA finite-length stack with a defined maximum is a trivial operation that can be implemented in an array in such a way that all stack operations are constant time.  If you want to pop an item and still keep it, then you have to duplicate that stack in *any* language, and that's never constant time.\n\nDo you want to use the array like a stack and still use it as an array?  like.. [1,2,3,4,5] ... \n\npop=&gt;5 pop=&gt;4 pop=&gt;3 \n\npush&lt;=9 push&lt;=9 push&lt;=9... \n\narray[4]=&gt;5... \n\npop=&gt;9?  If so, nothing at all does that.\n\nOtherwise, I still cannot seem to figure out what precisely you require.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c6go", "id": "c02c6mc", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424976, "id": "c02c6go", "author_flair_text": null, "distinguished": null, "edited": true, "name": "t1_c02c6go", "parent_id": "t1_c02c677", "body": "I'm thinking of an operation that removes the item that was added last, like the pop operation of a stack.\r\n\r\nYour scheme works, but only if you don't add elements to the arrays: if you add an element to the cdr of the array you have a problem (because you don't want to overwrite the original). You have to copy the elements to a new array, this destroys the amortized O(1) time. And there's the problem of modifying an elment in one of the arrays (e.g. x[5] = 3): do you want the other array to reflect the changes in the one you modify?\r\n\r\nThis isn't a problem in most cases, though.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 5, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424979, "body": "I'm uncertain as to what a \"cdr\" operation is in an array, but both answers I can come up with are constant time.\n\nA \"rest\" style cdr operation is as simple as setting a pointer equal to the next item in the array.\n\n(pseudocode as my C is a little rusty)\nint x[10] = [1,2,3,4,5,6,7,8,9,10];\nint *cdr = x+1;\n...cdr = [2,3,4,5,6,7,8,9,10]\n\nThe other possibility is that you're referring to nondestructive access to the *very* last item in the list.  This is equally trivial with a tail-counter, which is easily maintainable in trivial constant time unless you're destructively altering the array from the middle without reallocating.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c677", "parent_id": "t1_c02c603", "id": "c02c677", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 4, "name": "t1_c02c603", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424981, "score_hidden": false, "id": "c02c603", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5ky", "body": "If you enlarge the array by 50% every time you run out of space, that is amortized O(1). The downside is that a nondestructive tail/cdr operation is O(n).", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "gsg", "created_utc": "1193763693", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193765359", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "gsg", "created_utc": "1193765933", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193766707", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "gsg", "created_utc": "1193767363", "children": [{"controversiality": 0, "retrieved_on": 1427424964, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c7gh", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "score_hidden": false, "body": "Ok, good point.  One point for the list there.", "author": "novagenesis", "created_utc": "1193769440", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02c76p", "id": "c02c7gh", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c76p", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424967, "id": "c02c76p", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c731", "body": "Say, deleting elements from an ordered set.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02c731", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424967, "score_hidden": false, "body": "good point.\n\nI'm not sure when that would happen in a case you'd still want to use a list over an array, though...", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c6yz", "id": "c02c731", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02c6yz", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424969, "score_hidden": false, "id": "c02c6yz", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c6vq", "body": "Complexity is increased, yeah. It's something you pull out when you need performance and the profiler tells you that allocation is an issue.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c02c6vq", "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424971, "id": "c02c6vq", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c6nv", "body": "That's a good idea...I didn't even think of that... There's no managerial overhead?  It seems more complex to keep aware of all the linked lists you have (keep them in an array? :P)", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c6nv", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_5zffi", "retrieved_on": 1427424973, "body": "Allocation costs for linked lists can be kept low by using a 'free set' of nodes, marking them used/unused and reusing the storage as appropriate. This is probably a much better scheme for ordered data sets that see frequent insertions and deletions than array reallocation.\n\nFor unordered or monotonically growing data sets there wouldn't be any benefit. Know your data, I guess.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c5ky", "id": "c02c6nv", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c5ky", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 7, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "body": "Everything's true except that you spoke against yourself in one way that was wrng...\n\n&gt; Yes, arrays are slow to reallocate\n\nNot if you have a good implementation for buffer handling.  You have to allocate memory every single add in a list.  You only have to allocate memory when you cross bounds in arrays.  If you use an array allocation scheme, you'll find yourself making *far* fewer system allocation calls than a list ever would.\n\nI create an array of 100 items... when I want to place the 101st item, let's say the array reallocates up 50%, then copies...one expensive operation... then I can make 51 more adds before I reallocate again.\n\nYou have a list of 100 items, the 101st item is an allocation.  The 102nd item is an allocation.  All you're saving on is copying time.\n\nI bet it's faster to allocate 200 items and copy 100 variables than it is to allocate 1 item 100 times.\n\nFurther, if you even have a wild GUESS at a reasonable upper bound for your array, you can allocate it at compile time and reduce that to *0* unless you hit the upper limit.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c5fy", "id": "c02c5ky", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c5fy", "ups": 36, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424989, "score_hidden": false, "body": "Reading further, I think you need to look up this word \"simple\". It doesn't mean what you think it means.\r\n\r\n&gt; Arrays have a problem. They cannot be\r\n&gt; resized, so any change to their dimensions\r\n&gt; is slow ... Arrays are not simple. Lists\r\n&gt; are simple.\r\n\r\nEvery data structure has its advantages and disadvantages; hashtables, lists, arrays, red-black-trees, etc, all are valuable for specific situations. One might be fast to store, another fast to sort, fast to read, memory efficient, etc.\r\n\r\nDon't write one off just because it's not useful for one particular job.\r\n\r\nYes, arrays are slow to reallocate; so if you don't know in advance how many items are necessary, you might find that another data structure is a better choice.\r\n\r\nThis has nothing to do with whether arrays are \"simple\". From a low-level perspective they're the simplest type of data structure you can have.\r\n\r\nAnd if you're saying they're not simple to _use_, well, the answer is better library/language support, not a different data structure.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c587", "id": "c02c5fy", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424981, "subreddit_id": "t5_2fwo", "created_utc": "1193758901", "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "body": "is it a library, or a language feature?\n\nI would say the Post Office might be a language feature because the interface is defined in our daily lives.\n\nWe don't need to include&lt;postoffice.h&gt; or make a call to System.postoffice using an object.stamp reference.  We have to wrap a letter in an envelope, which gets sent as a package.\n\nFedex is a library.  USPS is a language feature.  Fedex is arguably better, but more work to use than just putting your letter in the mailbox and flipping up the flag.", "id": "c02c61o", "author": "novagenesis", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "name": "t1_c02c61o", "parent_id": "t1_c02c587", "score_hidden": false, "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "leoc", "created_utc": "1193764543", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193784036", "name": "t1_c02c96l", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424940, "score": 0, "score_hidden": false, "body": "[deleted]", "author": "[deleted]", "author_flair_text": null, "distinguished": null, "edited": true, "archived": true, "subreddit_id": "t5_2fwo", "ups": 0, "parent_id": "t1_c02c6s0", "id": "c02c96l", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 6, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424971, "body": "He's talking about simplicity of interface, you're talking about simplicity of implementation. [This distinction was hashed out](http://www.dreamsongs.com/WorseIsBetter.html) ([Reddit](http://reddit.com/info/2140/comments)) long ago.", "archived": true, "distinguished": null, "edited": true, "name": "t1_c02c6s0", "parent_id": "t1_c02c587", "id": "c02c6s0", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "name": "t1_c02chag", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424835, "score": 1, "created_utc": "1193873973", "id": "c02chag", "author": "brushbox", "archived": true, "distinguished": null, "edited": false, "body": "It is a matter of perspective. I agree that the postal solution is simpler, even though at first appearance I thought \"what could be easier than just getting up and walking\".\n\nBut then I thought about a few aspects:\n* distance\n* route planning\n* border security &amp; customs\n* accommodation\n* cost/time (and therefore the opportunity costs)\n* language issues.\n* and many more...\n\n...and then it became clear to me that using an established system that can deliver the letter in less than a week for around $1 and all I need to do is address, stamp and deliver to a post box is far far simpler in almost every way.\n\nSimpler in this post seems to consider the reliable encapsulation of \"involved\" (using that word to avoid saying \"complex\") processes. Since the \"surface area\" (the API) of the process is greatly reduced, it is much simpler for me.\n", "subreddit_id": "t5_2fwo", "score_hidden": false, "parent_id": "t1_c02c587", "ups": 1, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 68, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424992, "body": "&gt; I need to deliver a message to my friend\r\n&gt; in China. So the first solution is to\r\n&gt; walk to China and back. That solution\r\n&gt; will deliver the message. It is adequate.\r\n&gt; The second is to send a letter to my\r\n&gt; friend in China. This is also an adequate\r\n&gt; solution. But the latter ... is obviously simpler.\r\n\r\nHow is it simpler? It depends on additional agents (the postal service) and requires additional actions (encoding the message in the letter, posting it, the sorting and delivery process of the postal service) that weren't necessary for the first one.\r\n\r\nIMO, the reason why this is the correct solution is that it makes use of the existing infrastructure (the postal service).\r\n\r\nI.e. it's a _more efficient_ solution, not a simpler one.\r\n\r\nWell done for demonstrating the flaws in your own thesis.", "archived": true, "distinguished": null, "edited": true, "name": "t1_c02c587", "parent_id": "t3_5zffi", "id": "c02c587", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "arnoooooo", "created_utc": "1193751619", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 4, "author": "novagenesis", "created_utc": "1193757449", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "DannoHung", "created_utc": "1193776422", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193787319", "name": "t1_c02c9l0", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424935, "score": 1, "score_hidden": false, "id": "c02c9l0", "author": "novagenesis", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02c89x", "body": "I'd love it if the system did exactly what I want....except two things.\n\n1) I need an irrefutable proof that it'll always do exactly what I want no matter what\n2) I need the designer to take full responsibility if I want to kill someone (which I'd never erally do) only to have the program do it.", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c02c89x", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424952, "score_hidden": false, "body": "Wouldn't you want a system that did exactly what you want without having to interact with it at all?\n\nWell, I guess some people don't trust hard AI.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c5vv", "id": "c02c89x", "author_flair_css_class": null}], "subreddit": "programming", "ups": 4, "name": "t1_c02c5vv", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424984, "score_hidden": false, "id": "c02c5vv", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5as", "body": "&gt;\"Perfection is achieved, not when there is nothing left to add, but when there is nothing left to remove.\"\n\nBy that definition, no system is perfect unless you remove the GUI, mouse interaction, and keyboard interaction.\n\nYou want elegance in a language, not \"remove everything\".  You want a language where the core is so complex that all you have to do is tell it what you want.  Perfect is never having to worry about a memory leak.  Perfect is being able to manipulate data in any complicated way you want with one line of easily-human-readable code.  Perfect is something that has very easily-fixed compile-time errors and that you can trust with minimal testing to work on first successful compile.\n\nAnd I agree, screw buzzwords and consulting firms profiting on complicated languages.", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424991, "body": "\"Perfection is achieved, not when there is nothing left to add, but when there is nothing left to remove.\" Antoine de Saint-Exupery\n\nThe thing with complexity in programming is that it provides such a wealth of opportunities for consulting companies, book puiblishers, etc.  a lot of people like all the complexity and buzzwords that allow them to be \"the experts\". This is probably true in a lot of other domains, but the potential for abuse in programming is huge.\n\nJava and friends are the worst enemies of simplicity but the best friends of those who want to be able to charge millions for their \"expertise\". After all, who would use software that is not \"Enterprise Ready\" ?", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c5as", "parent_id": "t3_5zffi", "id": "c02c5as", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 5, "author": "onmytoes", "created_utc": "1193752081", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "revence27", "created_utc": "1193752376", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "arnoooooo", "created_utc": "1193752832", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "revence27", "created_utc": "1193754129", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "score": 1, "body": "agreed", "id": "c02c5kw", "author": "arnoooooo", "created_utc": "1193754411", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02c5kw", "parent_id": "t1_c02c5jy", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 3, "name": "t1_c02c5jy", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "score_hidden": false, "id": "c02c5jy", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5ex", "body": "I'm suggesting that if we are choosing a place to put all the complexity, it should definitely be under the hood.\n\nLibraries are this `under the hood', for example. They should, if possible, suck up all the complexity.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1193755535", "ups": 2, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424985, "score": 2, "body": "I beg to differ.  You shouldn't choose to discard a critically useful feature because it's implementation is \"non-trivial\".  You should find a way to develop that implementation in a way that minimizes bugs.\n\nPerhaps it'd be better to develop a language in Haskell than in C... perhaps not.  You still shouldn't decide \"let's NOT build this language feature because it makes the compiler more complex\".\n\nIf you're the US Postal Service, it's your job to deliver mail to everyone.", "id": "c02c5p4", "author": "novagenesis", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "name": "t1_c02c5p4", "parent_id": "t1_c02c5ex", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424989, "body": "I beg to differ. Simplicity is needed everywhere. A complex system is more likely to break and harder to maintain and improve on.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c5ex", "parent_id": "t1_c02c5df", "id": "c02c5ex", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193762857", "name": "t1_c02c6jz", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424974, "score": 1, "score_hidden": false, "body": "You can argue that, I will listen to you, but it goes against what the author of the article wrote: if it's not simple it's wrong.  If you're writing a compiler for, say, Haskell, and you're going for the utmost simplicity, some of those choices will trickle down to the user.  And this is true of any application: Does your simplification push work onto the user? And if it does, is that a valid simplification to make?  This article says \"yes.\"", "author": "onmytoes", "archived": true, "distinguished": null, "edited": true, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02c5df", "id": "c02c6jz", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c5df", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424990, "body": "Simplicity should not exist under the hood, because nobody looks down there.\n\nIn the electricity process, there is no simplicity. Simplicity is when you flip the switch, and the light comes on. Under the hood, it's something between voodoo and madness. There is no simplicity there. But in the user interface (like a programming language), simplicity _just can't be comprimised_.\nSimplicity is always percieved simplicity.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c5ce", "id": "c02c5df", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 4, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424989, "score": 4, "body": "Those languages might be a bit complex under the hood but :\n- would you rather have to deal with the complexity yourself in every program you write or have it done once and for all in the compiler ?\n- a lot of the complexity is caused by the need to adapt to the machine. Lisp on a Lisp Machine is simple.", "author": "arnoooooo", "created_utc": "1193752541", "distinguished": null, "edited": true, "id": "c02c5dv", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02c5dv", "parent_id": "t1_c02c5ce", "score_hidden": false, "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 8, "author": "ItsAConspiracy", "created_utc": "1193752696", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "pTymN", "created_utc": "1193755166", "children": [{"controversiality": 0, "retrieved_on": 1427424978, "subreddit_id": "t5_2fwo", "created_utc": "1193760634", "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "body": ";-)\n\nDoes that make programmers that use them... leaky concretizations?\n\n(When they produce leaks despite GC, that is.)", "id": "c02c69h", "author": "Gotebe", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "name": "t1_c02c69h", "parent_id": "t1_c02c5nu", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 0, "score_hidden": false, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "body": "Agreed. Garbage collectors aren't usually a leaky abstraction. :-)", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c5nu", "parent_id": "t1_c02c5ef", "id": "c02c5nu", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c5ef", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 8, "link_id": "t3_5zffi", "retrieved_on": 1427424989, "body": "Lexical closures really aren't hard to implement, if you've already got garbage collection. You just implement your stack frames as objects on the heap, each one referencing its enclosure.\r\n\r\nIt gets more complicated when you start optimizing, but that's true of any language.\r\n\r\nI would say that real simpicity is: making sure anything complicated only has to be done once. So, eg., I'd say that garbage collection is simple, because even though by itself it's complicated, it takes a whole class of complicated work and solves the problem so you can stop worrying about it.\r\n\r\nAfter a while I learned to apply this principle in my own programming...whenever I create an object, I think about how difficult it will be to use. I'll make the object more complicated, if that means its API is simpler. This has done wonders for my productivity and general mood.\r\n\r\nOf course, if you can make it simple at all levels, that's best of all.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c5ce", "id": "c02c5ef", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "novagenesis", "created_utc": "1193754915", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "julesjacobs", "created_utc": "1193758787", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193760186", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "julesjacobs", "created_utc": "1193763267", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193763962", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "julesjacobs", "created_utc": "1193773401", "children": [{"controversiality": 0, "retrieved_on": 1427424955, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02c82r", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "score_hidden": false, "body": "yikes!", "author": "novagenesis", "created_utc": "1193774914", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02c7v1", "id": "c02c82r", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c02c7v1", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424957, "score_hidden": false, "body": "Yeah, I wouldn't use Forth for a web application, for example. I'm just explaining the philosophy :)", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c6oy", "id": "c02c7v1", "author_flair_css_class": null}], "subreddit": "programming", "ups": 1, "name": "t1_c02c6oy", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424973, "score_hidden": false, "body": "&gt;I could say that a Java application is extremely complex because it requires the Java runtime and an OS\n\nExcept I think the point is language complexity, in this entire topic.\n\nIt's not about how complex the compiler is.\nIt's not about how complex the resulting executable is.\nIt's not about how complex the moon and the stars are.\n\nIt's about experience.  If I give a client a product with no gui because it wasn't as \"complex\", and an interface that uses one-letter arguments with multiple meanings across an FSM (because it's easier than parsing full words), I'll get fired.\n\nA lot of languages feel like that.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c6ly", "id": "c02c6oy", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424974, "body": "It depends on your point of view. I could say that a Java application is extremely complex because it requires the Java runtime and an OS. This is millions of lines of code.\r\n\r\nSuppose that all software on earth is lost. Would we start coding an OS and then a Java compiler and runtime, in machine code? No, we'd code a Forth in machine code, and an OS in Forth, etc. And it would all be much more efficient, because we don't code the 99% bloat.\r\n\r\nSo the total complexity is lower, but the complexity of the application could be higher, because you have to reinvent a lot of things.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c6ly", "parent_id": "t1_c02c67i", "id": "c02c6ly", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "[deleted]", "created_utc": "1193765422", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "novagenesis", "created_utc": "1193766840", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "happyhappyhappy", "created_utc": "1193770053", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "novagenesis", "created_utc": "1193770450", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "OMouse", "created_utc": "1193773155", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "novagenesis", "created_utc": "1193775006", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "OMouse", "created_utc": "1193775384", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193786328", "name": "t1_c02c9hb", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424936, "score": 0, "score_hidden": false, "body": "Great Computer Language Faceoff?  Forth was significantly slower?\n\nThe fact that using the stack is the fastest native method, so unless a forth compiler converts the code to not using the stack unless necessary (kinda tough, but definitely doable) you have extra operations", "author": "novagenesis", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 0, "parent_id": "t1_c02c84u", "id": "c02c9hb", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424954, "body": "&gt;Because forth definitely doesn't do inner loops as fast as C does...\n\nHow would you (or I) test that?", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c84u", "parent_id": "t1_c02c835", "id": "c02c84u", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c835", "ups": 0, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424954, "score_hidden": false, "id": "c02c835", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c7tz", "body": "&gt;Why is that so important?\n\nBecause forth definitely doesn't do inner loops as fast as C does...\n\nand certainly doesn't do classes as well as C++.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c7tz", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_5zffi", "retrieved_on": 1427424958, "body": "&gt;I spent a few days trying to find good Forth tutorials and ended up dead every time.\n\nHere you go: http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Tutorial.html#Tutorial\n\nI hope it's good enough.\n\nYou should also try Factor out. It adds a library and a development environment that is quite helpful.\n\nAnd of course there's Thinking Forth right here: http://thinking-forth.sourceforge.net/\n\n&gt;the compiler didn't seem to make .o files\n\nWhy is that so important?", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c7k7", "id": "c02c7tz", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "score_hidden": false, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424961, "id": "c02c7k7", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c7k7", "parent_id": "t1_c02c7ig", "body": "&gt;Your message reads like \"I'd heard Perl looked like line noise and once I jumped into learning it I realized that it did look like line noise so I gave up.\"\n\nI spent a few days trying to find good Forth tutorials and ended up dead every time.  My general method of learning a language consists of me trying to implement a non-trivial on the job task with it.  Forth is the only language that blew up in complexity when I tried it.\n\nPerl happened to be the language that worked most easily.  Then Scheme and Common Lisp (neck and neck), then C/C++ (which I already knew), and finally Haskell just ahead of Forth...those are the only languages I've played that game with recently.\n\nI didn't really find much in the way of good tutorials, and the compiler didn't seem to make .o files... yeah I gave up early on Forth thinking what I found was a trashy old language a few suckers didn't let go of (and some of those certainly exist)", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c7ig", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424962, "body": "Forth is very different and takes time to understand.  I'm not trying to be snide or elitist.  It's a simple language, but the learning curve to doing useful things in Forth is much steeper than advocates want to admit.  It's also not the perfect language for all uses.\n\nYour message reads like \"I'd heard Perl looked like line noise and once I jumped into learning it I realized that it did look like line noise so I gave up.\"", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c73o", "id": "c02c7ig", "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "LaurieCheers", "created_utc": "1193779615", "children": [{"controversiality": 0, "retrieved_on": 1427424935, "subreddit_id": "t5_2fwo", "created_utc": "1193787517", "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "body": "Witty retort.", "author": "novagenesis", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit": "programming", "name": "t1_c02c9lz", "parent_id": "t1_c02c8nq", "score_hidden": false, "id": "c02c9lz"}], "subreddit": "programming", "name": "t1_c02c8nq", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424947, "body": "Pointless theme-continuing reply.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c73o", "id": "c02c8nq", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c73o", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 3, "link_id": "t3_5zffi", "retrieved_on": 1427424967, "id": "c02c73o", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c6vz", "body": "Pointless Flame response.\n\nI *was* recently seriously interested in learning about Forth, but the moment I started, it showed to be *exactly* what I just said it was.\n\nPlease provide counterargument.  I'm genuinely interested.\n\nI actually would prefer to use Forth than Assembly if they had identical performance in the system, but I wouldn't consider coding in either to be 'simple'.  In that vein, I wouldn't call it bashing at all.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 0, "name": "t1_c02c6vz", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424971, "score_hidden": false, "id": "c02c6vz", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c67i", "body": "[deleted]", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "ItsAConspiracy", "created_utc": "1193767005", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "novagenesis", "created_utc": "1193769408", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "julesjacobs", "created_utc": "1193773250", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193774904", "name": "t1_c02c82p", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424955, "score": 1, "score_hidden": false, "body": "I skimmed through a lot of it...it kinda argued like a salespitch to me, though.\n\nI still don't get a grasp as to why it argues itself \"high level\"... I'd honestly love to know, the elegance of the language interests me...I just can't seem to see myself building a compiler in it, or a game, or a gui app.", "author": "novagenesis", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02c7ub", "id": "c02c82p", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02c7ub", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424958, "score_hidden": false, "body": "http://thinking-forth.sourceforge.net/\r\n\r\nCheck it out!", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c7g7", "id": "c02c7ub", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424964, "id": "c02c7g7", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c7g7", "parent_id": "t1_c02c74i", "body": "I'll be honest...I never found Thinking Forth.  I'll check it out.  I am always a fan of new languages.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c74i", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424967, "body": "I don't know, I read about half of Thinking Forth recently (which is worth reading for programmers in any language, btw) and I gotta admit the language intrigues me.\r\n\r\nIt can get pretty horrendous if people do a lot of stack manipulation...but Brodie doesn't do it that way. His examples read almost like English.\r\n\r\nTakes some work to get it that nice, I expect, I haven't actually tried working in the language yet. Seems like fun tho.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c67i", "id": "c02c74i", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 1, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424979, "id": "c02c67i", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c67i", "parent_id": "t1_c02c61a", "body": "How would you say it tries to make the code simple, though?  I would say that it doesn't.  It's like a variation of assembly more inexorably tied to the stack.\n\nHuman readability is out the window.\nReasonable implementation of complex features is out the window, too.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c02c61a", "controversiality": 0, "archived": true, "ups": 3, "link_id": "t3_5zffi", "retrieved_on": 1427424981, "id": "c02c61a", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5mv", "body": "Forth tries to make the whole system (application+compiler) as simple as possible.", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 4, "author": "mage2k", "created_utc": "1193779415", "children": [{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c9lh", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424935, "score": 2, "score_hidden": false, "id": "c02c9lh", "author": "novagenesis", "created_utc": "1193787405", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 2, "parent_id": "t1_c02c8my", "body": "enterprise is a buzz word that, to me, means 'big', distributed, and jobs resting on its reliability.\n", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c8my", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 4, "link_id": "t3_5zffi", "retrieved_on": 1427424947, "id": "c02c8my", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5mv", "body": "You had me until 'enterprise'. :)", "author_flair_css_class": null}], "subreddit": "programming", "ups": 6, "name": "t1_c02c5mv", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "score_hidden": false, "id": "c02c5mv", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c5ce", "body": "I think you're missing the point.\n\nThe author is promoting a language that's simple to program *in*.\n\nCompiler complexity vs code complexity is a very clear one.  The only way to achieve a simple compiler and simple code is to have complex libraries (technically, this is harder to optimize than the compiler itself).\n\nForth's \"actual simplicity\" means you don't have access to closures, lists, etc, unless they exist in a library.  The code becomes unbelievably complex unless libraries already exist for that.  As a language, forth is fun, but I'd shoot myself in the head before dreaming of building an enterprise product in it.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 5, "name": "t1_c02c5ce", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424990, "score_hidden": false, "body": "The author promotes simplicity, yet he's a proponent of languages that are MUCH MORE COMPLEX underneath the hood.  So it's more about perceived simplicity than actual simplicity (\"actual simplicity\" is one of the key tenets of Forth, which I'm only mentioning because of the Brodie quote at the top of the article).", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "id": "c02c5ce", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 7, "author": "[deleted]", "created_utc": "1193752273", "children": [{"controversiality": 0, "retrieved_on": 1427424989, "subreddit_id": "t5_2fwo", "created_utc": "1193752920", "ups": 5, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 5, "body": "That wouldn't have shown much of the usefulness of the closures/blocks the author talks about, would it? :o)\n\nUpmodded, though. Nice one-liner.", "author": "revence27", "archived": true, "distinguished": null, "edited": false, "id": "c02c5f7", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02c5f7", "parent_id": "t1_c02c5d0", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 3, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424989, "score": 3, "body": "That is pretty cool.  But I think he was actually saying that the Ruby way he showed was good too, as it cleans up the loose ends for you and eliminates that class of bugs.", "author": "TheManWithNoName", "created_utc": "1193753447", "distinguished": null, "edited": false, "id": "c02c5hj", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02c5hj", "parent_id": "t1_c02c5d0", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193759072", "ups": 2, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424981, "score": 2, "score_hidden": false, "id": "c02c62g", "author": "julesjacobs", "author_flair_text": null, "distinguished": null, "edited": true, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02c62g", "parent_id": "t1_c02c5d0", "body": "TIMTOWDI :)\r\n\r\n    puts IO.readlines('/etc/passwd')\r\n    puts open('/etc/passwd').read\r\n    puts *open('/etc/passwd')\r\n    puts `cat /etc/passwd`", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c5d0", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 7, "link_id": "t3_5zffi", "retrieved_on": 1427424990, "id": "c02c5d0", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "body": "[deleted]", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 17, "author": "morner", "created_utc": "1193754482", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 23, "author": "Homunculiheaded", "created_utc": "1193755860", "children": [{"controversiality": 0, "retrieved_on": 1427424950, "subreddit_id": "t5_2fwo", "created_utc": "1193778032", "ups": 0, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 0, "body": "When you start describing a natural language in programming terms, you're lost.  If you want to retain possession of your soul, become a plumber.", "author": "mage2k", "archived": true, "distinguished": null, "edited": false, "id": "c02c8hw", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02c8hw", "parent_id": "t1_c02c5qi", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 23, "score_hidden": false, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424985, "body": "Also I *like* that English is a dynamically punned language where you don't have to declare whether or not you are using a pun and the reader will be able to interpret it from the context.", "archived": true, "distinguished": null, "edited": true, "name": "t1_c02c5qi", "parent_id": "t1_c02c5l6", "id": "c02c5qi", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": -4, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424984, "score": -4, "id": "c02c5uw", "author": "novagenesis", "created_utc": "1193757168", "distinguished": null, "edited": false, "body": "God *damn*, I hate it when people are annoyed by type-slang.\n\nYou attack people who use \"lol\" also?\n\n\nProgrammers are a subculture, and some programmers use language context.  Fine.  In the above post you are guilty of a more obfuscated equivalent thereof.\n\n&gt; God damn\n\nNot originally intended to be an expletive, it evolved into the spoken and written English languages.  That's just a coincidence that it evolved into both.  It's considered unprofessional to use \"can't\" or \"wouldn't\" in written documents, but it's considered unnecessary to use \"can not\" and \"would not\" a spoken context.\n\nSo now we have a phrase, bastardized slang, misused in a language, becoming a standard for those who use it.\n\nEO-RANT (just for you)", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02c5uw", "parent_id": "t1_c02c5l6", "score_hidden": false, "author_flair_css_class": null}, {"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 8, "author": "[deleted]", "created_utc": "1193760151", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 4, "author": "ndewitt", "created_utc": "1193760556", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "LaurieCheers", "created_utc": "1193761531", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "prockcore", "created_utc": "1193777091", "children": [{"controversiality": 0, "retrieved_on": 1427424947, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02c8mm", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 2, "score_hidden": false, "body": "I don't think that's ironic yet...\n\nMaybe if you reschedule it because the original date was forecast to rain... and as it turns out, the new date is the only rainy day that month.", "author": "LaurieCheers", "created_utc": "1193779307", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 2, "parent_id": "t1_c02c8d9", "id": "c02c8mm", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 3, "name": "t1_c02c8d9", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424951, "score_hidden": false, "body": "It is if you're a weatherman and you chose that specific date for your wedding because it was going to be sunny.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c6e8", "id": "c02c8d9", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02c8ij", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424950, "score": 1, "body": "I would cry if it wasn't already raining.", "author": "mage2k", "created_utc": "1193778152", "distinguished": null, "edited": false, "id": "c02c8ij", "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02c6e8", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "ups": 3, "name": "t1_c02c6e8", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424976, "score_hidden": false, "body": "You mean, like rain on your wedding day?\r\n\r\nYeah, that is _so_ ironic.", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02c691", "id": "c02c6e8", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424936, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02c9jr", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 2, "score_hidden": false, "body": "Actually, \"latter ... letter\" is consonance (in addition to alliteration).", "author": "Tommah", "created_utc": "1193786898", "distinguished": null, "edited": true, "author_flair_text": null, "subreddit": "programming", "ups": 2, "parent_id": "t1_c02c691", "id": "c02c9jr", "author_flair_css_class": null}], "subreddit": "programming", "ups": 4, "name": "t1_c02c691", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424978, "score_hidden": false, "id": "c02c691", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c67d", "body": "right - it's an alliteration.\n\nI also dislike when people say something is ironic when it's really just a bummer.", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": 1, "author": "revence27", "created_utc": "1193761025", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 5, "author": "[deleted]", "created_utc": "1193762062", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "ups": 2, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424974, "score": 2, "body": "Now _that_ was a _sweet, sweet_ pun. :o) Upmodded.", "author": "revence27", "created_utc": "1193762841", "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02c6jw", "parent_id": "t1_c02c6ga", "score_hidden": false, "id": "c02c6jw"}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193778346", "name": "t1_c02c8j6", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424950, "score": 1, "score_hidden": false, "id": "c02c8j6", "author": "mage2k", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t1_c02c6ga", "body": "Exactly, unfortunately my innate speech patterms (I guess?) tend to result in puns, un!ntended and  often have to follow up sentence fragments, clauses, and wholes with \"no pun intended\" (lowercase !ntended).  With text, I reword that shit.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 5, "name": "t1_c02c6ga", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424976, "score_hidden": false, "id": "c02c6ga", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c02c6bj", "body": "I guess I'm not familiar with the term \"phonetic pun.\" But if it wasn't intended (I'm sorry, if it was !intended), you would have just left out the phrase \"of the letter,\" since it makes the passage less clear.\n\nBut \"no pun intended,\" or any shorthand version of it, is almost always a lie in written communication. If you really hadn't intended the pun, you probably wouldn't have realized you had made one, until after the fact. And in writing, you could just go ahead a remove the pun, particularly in a case like this where the phase harms readability. \n\nIn speech, someone legitimately may say \"no pun intended,\" because they can't go back and edit what they just said. Still, even in speech, I suspect the pun is intended more often than not, and the phase \"no pun intended\" is used to add emphasis (i.e., draw attention to, not deflect from, the pun), just as the word \"literally\" is misused.\n\nHow ironic. A discussion of computer languages has literally turned into a discussion of natural language, natually (pun !!intended).", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 1, "name": "t1_c02c6bj", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424977, "score_hidden": false, "body": "It was a phonetic pun. !intended, you can trust.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02c67d", "id": "c02c6bj", "author_flair_css_class": null}], "subreddit": "programming", "ups": 8, "name": "t1_c02c67d", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424979, "score_hidden": false, "id": "c02c67d", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c02c5l6", "body": "Agreed. It also bugs me that 99.44% of the time, when someone says, \"no pun intended,\" the pun really was intended.  But this guys usage was even worse. \"the latter, of the letter\" is not a pun, and his (failed) attempt at being clever was clearly intended. It LITERALLY drives me nuts (misuse of \"literally\" intended).", "author_flair_css_class": null}], "subreddit": "programming", "ups": 17, "name": "t1_c02c5l6", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424987, "score_hidden": false, "id": "c02c5l6", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "body": "&gt; pun !intended\n\nGod *damn*, I hate it when nerds use programming syntax in prose. I wish that guy on bash.org would hurry up and invent his face-stab-over-IP device.", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "sam512", "created_utc": "1193756616", "children": [{"controversiality": 0, "retrieved_on": 1427424984, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02c5vc", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 6, "score_hidden": false, "body": "[deleted]", "author": "[deleted]", "created_utc": "1193757322", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 6, "parent_id": "t1_c02c5t6", "id": "c02c5vc", "author_flair_css_class": null}, {"subreddit": "programming", "gilded": 0, "downs": 0, "score": -1, "author": "novagenesis", "created_utc": "1193759464", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "grauenwolf", "created_utc": "1193761064", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": -2, "author": "novagenesis", "created_utc": "1193762858", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "grauenwolf", "created_utc": "1193763960", "children": [{"controversiality": 0, "retrieved_on": 1427424968, "subreddit_id": "t5_2fwo", "created_utc": "1193766570", "ups": 0, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 0, "body": "Wow, now that was a seriously hideous trol..\n\n&gt;Occam's Razor is about evaluating theories, not code, and thus is totally inappropriate\n\nCode theory seems appropriate to me.  Arguing a language better is theoretical, not concrete.\n\n&gt;For example:\n\nYour examples are insulting and do nothing towards the process.  I've read the articles, and the only space monkeys are trolling reddit.\n\n&gt;The only difference is the additional actors, the space monkeys, needed by the second theory.\n\nOversimplified, but fine.\nThe two languages produce the same output functionality but different source and require additional actors.  Since language theory can well avoid the contents of the compiled code so long as the functionality\nis the same, you have space-monkey code in C and \"reddit troll\" in haskell, the reddit troll is simpler.\n\n&gt;Keep in mind that Occam said the simplest answer \"tends to be correct\"\n\nI concur.  C may be a 'better' overall language than Haskell (if you can define better), even though Haskell is a 'simpler' one.\n\n&gt;Moving on to software, an example would be using a for loop verses writing the same machine code with assembly. Since they are identical, the only consideration is simplicity.\n\nWell, 'teach, nice hole you dug yourself.  Your example is exactly why I brought up Occam's Razor in a half-context at all.  \n\nNow the comparison that fits the ongoing topic (if you can read it without monkeys pulling the plug) would be a for loop vs each/map/fold.\n\nHave a nice day, Mr. troll.", "author": "novagenesis", "author_flair_text": null, "distinguished": null, "edited": false, "author_flair_css_class": null, "archived": true, "subreddit": "programming", "name": "t1_c02c72g", "parent_id": "t1_c02c6ox", "score_hidden": false, "id": "c02c72g"}], "subreddit": "programming", "score_hidden": false, "ups": 1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424973, "body": "Starting with the introduction found in the link you posted.\r\n\r\n&gt; This is often paraphrased as \"All things being equal, the simplest solution tends to be the right one.\" In other words, when multiple competing theories **are equal in other respects**, the principle recommends selecting the theory that introduces the fewest assumptions and postulates the fewest entities. It is in this sense that Occam's razor is usually understood.\r\n\r\nFor the sake of argument we will set aside the fact that Occam's Razor is about evaluating theories, not code, and thus is totally inappropriate.\r\n\r\nOccam's Razor is for comparing theories that are equal in all other respects. For example:\r\n\r\n&gt; Novagenesis is misapplying Occam's Razor because he didn't bother reading the article on it.\r\n\r\nvs.\r\n\r\n&gt; Novagenesis is misapplying Occam's Razor because space monkeys unplug his computer every time he tries to read the page.\r\n\r\nThe theories are identical in terms of what can be measured by an outside observer. The only difference is the additional actors, the space monkeys, needed by the second theory.\r\n\r\nKeep in mind that Occam said the simplest answer \"tends to be correct\". There may very well be space monkeys camped out in your living room, though chances are there are none.\r\n\r\n-----\r\n\r\nMoving on to software, an example would be using a for loop verses writing the same machine code with assembly. Since they are identical, the only consideration is simplicity.\r\n", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c6ox", "parent_id": "t1_c02c6k1", "id": "c02c6ox", "author_flair_css_class": null}], "subreddit": "programming", "ups": -2, "name": "t1_c02c6k1", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424974, "score_hidden": false, "id": "c02c6k1", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02c6bq", "body": "Ok, what if version 1 has better performance and memory use, but version 2 has less side effects and gets coded in 1/10th the time?\n\nOccam's Razor can always apply so long as the following is true for both versions: \n\n\"it works\" and \n\n\"it works comparably OR reasonably well\"\n\n", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424977, "id": "c02c6bq", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c6bq", "parent_id": "t1_c02c64j", "body": "Occam's Razor would only apply if two versions were identical in performance, memory use, and side effects.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": -1, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424980, "body": "http://en.wikipedia.org/wiki/Occam's_Razor", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c64j", "parent_id": "t1_c02c5t6", "id": "c02c64j", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "created_utc": "1193762076", "ups": 4, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424976, "score": 4, "body": "It doesn't apply to programming, either.", "id": "c02c6gc", "author": "finix", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "name": "t1_c02c6gc", "parent_id": "t1_c02c5t6", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c5t6", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 3, "link_id": "t3_5zffi", "retrieved_on": 1427424984, "id": "c02c5t6", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t3_5zffi", "body": "Note: the \"if it is not simple, it is wrong\" principle does not apply to the fields of science, mathematics, politics or ethics.", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "joesb", "created_utc": "1193756654", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 6, "author": "LaurieCheers", "created_utc": "1193761779", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 0, "author": "joesb", "created_utc": "1193785214", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424903, "score": 1, "body": "In the OP, \"correct\" means the best one (i.e. the correct one _to use_), and \"wrong\" means \"not the best one\". Under this definition, they can't both be wrong.\r\n\r\nWhat you're talking about is a different concept - \"wrong\" meaning that it doesn't actually work. That comes under 'adequate'.", "author": "LaurieCheers", "created_utc": "1193823254", "distinguished": null, "edited": true, "author_flair_css_class": null, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02cc2g", "parent_id": "t1_c02c9da", "score_hidden": false, "id": "c02cc2g"}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 0, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424938, "id": "c02c9da", "author_flair_text": null, "distinguished": null, "edited": true, "name": "t1_c02c9da", "parent_id": "t1_c02c6fb", "body": "So if both solutions are not wrong then are both solutions correct? \n\n\nIf they are both correct, you don't have to tell me the simpler solution is *also* correct.\n\n\nIf it is possible for solution to be neither correct or wrong. Then I should rephrase my question to: \n\n\n\"The second statement doesn't take in to account when both solutions are neither correct or wrong.\"", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c6fb", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 6, "link_id": "t3_5zffi", "retrieved_on": 1427424976, "id": "c02c6fb", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t1_c02c5tb", "body": "If an \"adequate\" solution is wrong, then I suggest your definition of \"adequate\" is not adequate.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02c5tb", "ups": 2, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424984, "score_hidden": false, "id": "c02c5tb", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "body": "&gt; `Given two adequate\nsolutions, the correct one is the simpler.' [1]\n&gt;Sorry, but I beg to differ. I'd insist, with examples, that given two adequate\nsolutions, the simpler one is the correct one.\n\nThe second statement doesn't take in to account when both solutions are wrong.\n\n&gt; For every complex problem, there is an answer that is clear, simple--and\nwrong.", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c5xx", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424983, "score": 10, "score_hidden": false, "body": "\"the simpler one is the correct one.\"\r\n\r\nThis is the type of person everyone else at the table wants to kill instantly.  He's the type that will sit there silently for hours and when all's said and done, throw everything out the window with some retarded argument that really doesn't make any difference at all.\r\n", "author": "turkourjurbs", "created_utc": "1193757985", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 10, "parent_id": "t3_5zffi", "id": "c02c5xx", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "edheil", "created_utc": "1193757986", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "revence27", "created_utc": "1193758631", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "author_flair_text": null, "ups": 2, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424971, "score": 2, "body": "I will, *merci beaucoups!*\n\n", "id": "c02c6x3", "author": "edheil", "created_utc": "1193765609", "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02c6x3", "parent_id": "t1_c02c60h", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424981, "body": "Not very many of them, but they are now all available (the directory, that is), here: http://freeshells.ch/~revence/txts\n\n:o) _Amusez-vous!_", "archived": true, "distinguished": null, "edited": true, "name": "t1_c02c60h", "parent_id": "t1_c02c5xy", "id": "c02c60h", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c5xy", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 6, "link_id": "t3_5zffi", "retrieved_on": 1427424983, "body": "I love reading this guy's cheerfully opinionated essays.\n\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "id": "c02c5xy", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 1, "author": "[deleted]", "created_utc": "1193758328", "children": [{"controversiality": 0, "retrieved_on": 1427424980, "subreddit_id": "t5_2fwo", "created_utc": "1193759562", "ups": 2, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 2, "id": "c02c64y", "author": "novagenesis", "archived": true, "distinguished": null, "edited": false, "body": "Good question..I tried FORTH and found very quickly that the \"high ceiling\" is mostly just buzz and no higher than the ceiling of C\n\n(someone please give me an example showing me wrong)", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02c64y", "parent_id": "t1_c02c5zb", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c5zb", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 1, "link_id": "t3_5zffi", "retrieved_on": 1427424983, "id": "c02c5zb", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "body": "[deleted]", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 25, "author": "[deleted]", "created_utc": "1193758681", "children": [{"controversiality": 0, "retrieved_on": 1427424925, "subreddit_id": "t5_2fwo", "created_utc": "1193796283", "ups": 5, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 5, "body": "Your argument is very simple, so it must be correct.", "author": "Rofl_Waffler", "archived": true, "distinguished": null, "edited": false, "id": "c02cacq", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02cacq", "parent_id": "t1_c02c60r", "score_hidden": false, "author_flair_css_class": null}], "subreddit": "programming", "ups": 25, "name": "t1_c02c60r", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424981, "score_hidden": false, "id": "c02c60r", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "body": "Given the amount of discussion here, I come to the conclusion that the article is not simple.\r\n\r\nTherefore, it is wrong. QED. ", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 5, "author": "Entropy", "created_utc": "1193758773", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193760860", "name": "t1_c02c6ao", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424978, "score": 0, "score_hidden": false, "id": "c02c6ao", "author": "grauenwolf", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 0, "parent_id": "t1_c02c618", "body": "Neither could I. ", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 5, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424981, "body": "I couldn't get past the first retarded example.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c618", "parent_id": "t3_5zffi", "id": "c02c618", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 2, "author": "sblinn", "created_utc": "1193759167", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193794582", "ups": 2, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424927, "score": 2, "score_hidden": false, "body": "More on taste, art, and software:\n\nhttp://www.paulgraham.com/goodart.html\n\n&gt; I grew up believing that taste is just a matter of personal preference. Each person has things they like, but no one's preferences are any better than anyone else's. There is no such thing as good taste.\n&gt; \n&gt; Like a lot of things I grew up believing, this turns out to be false, and I'm going to try to explain why.\n&gt;\n&gt; One problem with saying there's no such thing as good taste is that it also means there's no such thing as good art.\n\nhttp://thinkexist.com/quotes/claude_debussy/\n\n&gt; \u201cMusic is the silence between the notes.\u201d\n&gt;\n&gt; \u201cI love music passionately. And because I love it I try to free it from barren traditions that stifle it.\u201d\n&gt;\n&gt; \u201cMusic is the arithmetic of sounds as optics is the geometry of light.\u201d\n&gt;\n&gt; \u201cArt is the most beautiful deception of all. And although people try to incorporate the everyday events of life in it, we must hope that it will remain a deception lest it become a utilitarian thing, sad as a factory.\u201d\n&gt;\n&gt; **\u201cExtreme complication is contrary to art.\u201d**\n&gt;\n&gt; \u201cWorks of art make rules; rules do not make works of art.\u201d\n\nhttp://thinkexist.com/quotation/computers_are_useless-they_can_only_give_you/14398.html\n\n&gt; \u201cComputers are useless. They can only give you answers.\u201d - Pablo Picasso", "author": "sblinn", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02ca7i", "parent_id": "t1_c02c62u", "id": "c02ca7i", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c62u", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 2, "link_id": "t3_5zffi", "retrieved_on": 1427424980, "body": "I find it curious that my tastes in art and music run towards the impressionists (Debussy, Monet), and that I can barely stand minimalistic art or music. Yet in landscape, architecture, and software, I crave minimalism to the exclusion of nearly all other concerns.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "id": "c02c62u", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193759848", "name": "t1_c02c667", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424979, "score": 3, "score_hidden": false, "id": "c02c667", "author": "karlhungus", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 3, "parent_id": "t3_5zffi", "body": "Article could have been simpler, therefore it must be wrong... oh snap!", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193760213", "name": "t1_c02c67o", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424979, "score": 3, "score_hidden": false, "id": "c02c67o", "author": "[deleted]", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "ups": 3, "parent_id": "t3_5zffi", "body": "Simplicity applies to writing as well.  This essay would have been a lot more helpful if it stuck to the point and avoided cute nonsense syntax and his [pet peeve] asides.\n\nAs it was, I just glossed over it to pick up the main points.  I may have missed a valuable diamond in the rest of the manure, but I couldn't be bothered to dig for it.", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 19, "author": "ndewitt", "created_utc": "1193760219", "children": [{"controversiality": 0, "retrieved_on": 1427424960, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c7qx", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "score_hidden": false, "id": "c02c7qx", "author": "[deleted]", "created_utc": "1193772203", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02c67p", "body": "Yep, he says he begs to differ, but since his point doesn't differ even slightly from Brodie's that makes no sense.", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424960, "subreddit_id": "t5_2fwo", "created_utc": "1193772487", "ups": 7, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 7, "body": "I think we can all agree that the author, though he provoked an interesting debate, is a bit of a smug asshole.", "author": "vin_diesel", "archived": true, "distinguished": null, "edited": true, "id": "c02c7rt", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02c7rt", "parent_id": "t1_c02c67p", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424902, "subreddit_id": "t5_2fwo", "created_utc": "1193824087", "ups": 2, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 2, "body": "The author didn't read Brodie's quote correctly. Imagine that Brodie said \"... the correct one is simpler\", rather than \"the simpler\". *Then* the author's point would be valid: it's less important that the correct solution turns out to be simpler than the incorrect solution; what's more important is that the simpler solution turns out to be the correct one. Formally the two are saying the same thing, but the latter is more useful as a guideline. \n\nHowever, Brodie already *is* making that more useful point, it's just that the author misread him to be saying something else.", "id": "c02cc3n", "author": "anatoly", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "name": "t1_c02cc3n", "parent_id": "t1_c02c67p", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 19, "name": "t1_c02c67p", "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424979, "score_hidden": false, "id": "c02c67p", "author_flair_text": null, "distinguished": null, "edited": true, "parent_id": "t3_5zffi", "body": "&gt;Leo Brodie wrote, in his book, Thinking Forth, that `Given two adequate solutions, the correct one is the simpler.' [1]\n&gt;\n&gt;Sorry, but I beg to differ. I'd insist, with examples, that given two adequate solutions, the simpler one is the correct one.\n\nI had to stop reading right there.  He stated the **exact same thing** as Leo Brodie.\n\n&gt;the correct one is the simpler.\n\nvs\n\n&gt;the simpler one is the correct one.\n\nThose two statements mean the same thing.  If you are looking at two adequate solutions, and you say that the correct one is the simpler (of the two) then you're postulating that you can identify the correctness by the simplicity.  \n\nThe author of this article thinks he's making some kind of clever point by rearranging the words, but he's not actually making a new point.  He's arguing that the simplest solution is the correct one.  This is what Brodie is arguing.\n\nIn both cases, the correct solution will be the simplest adequate solution.  There is no disagreement.", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c6gr", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424975, "score": 6, "score_hidden": false, "id": "c02c6gr", "author": "Gotebe", "created_utc": "1193762152", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 6, "parent_id": "t3_5zffi", "body": "In *reality*, absolutely wrong on arrays.\n\nFirst and foremost, arrays are bad for *insertion*, not growth. Growth is handled fine by allocating more when needed and that makes copying less important. Plus, copying is, more often than not, inexpensive, as only references are copied. For lists, both insertion and growth requires allocation all the time, which is (somewhat) expensive. I bet lists can't beat arrays in growth scenarios.\n\nPlus, arrays are better for the locality of references, which is important with caches.\n\nLists that magically turn into arrays is a sufficiently smart compiler/runtime/whatever fallacy and happens seldom.\n\nIt's also equally easy to go past the end of a list as it is for an array. It's strictly about iteration mechanism used, not about underlying container implementation. That part is just plain wrong.\n\nFile example is irrelevant. Nobody in their right mind uses that plain C approach for such stuff. \n\nYes, I see how one can get worked up about issues mentioned *if* the baseline is C language. But, is it? Certainly not for me.", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193762491", "ups": 5, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424975, "score": 5, "score_hidden": false, "body": "I'm a simple person...\n\n... I could be wrong.", "author": "[deleted]", "archived": true, "distinguished": null, "edited": true, "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02c6id", "parent_id": "t3_5zffi", "id": "c02c6id", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 6, "author": "[deleted]", "created_utc": "1193762857", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "jng", "created_utc": "1193787195", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193809663", "ups": 3, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424912, "score": 3, "score_hidden": false, "body": "I wish more people understood that it is impossible for an article to be a mirror of what you believe. More like a simple number of points in there that you agree with. And what you don't agree with only allows you to understand better what you believe.\n\nThe spirit of sensible debate is generally lost in these geek circles, because the least accomodating are the loudest. And you are being downmodded, unfortunately.", "author": "revence27", "archived": true, "distinguished": null, "edited": true, "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02cbdi", "parent_id": "t1_c02c9ki", "id": "c02cbdi", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424935, "body": "Thanks for the sweeping generalization.\n\nDo you really believe you get every single point in the article, and that there is none of value? Can't you consider you missed something? I suggest you do so, if only to become still wiser.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c9ki", "parent_id": "t1_c02c6k0", "id": "c02c9ki", "author_flair_css_class": null}], "subreddit": "programming", "name": "t1_c02c6k0", "score_hidden": false, "controversiality": 0, "author_flair_text": null, "ups": 6, "link_id": "t3_5zffi", "retrieved_on": 1427424974, "body": "[deleted]", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "id": "c02c6k0", "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "queisser", "created_utc": "1193762859", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "mage2k", "created_utc": "1193779203", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193791746", "name": "t1_c02c9zk", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424930, "score": 2, "score_hidden": false, "body": "I'm claiming extra nerd points for considering tautology to be a trivial (and thus non-nerdy) word. ", "author": "novagenesis", "archived": true, "distinguished": null, "edited": false, "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 2, "parent_id": "t1_c02c8m9", "id": "c02c9zk", "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424901, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02cc6f", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "score_hidden": false, "id": "c02cc6f", "author": "Gotebe", "created_utc": "1193826560", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 1, "parent_id": "t1_c02c8m9", "body": "I'm revoking your points for claiming, but failing, to use word *tautaology*.\n\nBut otherwise, I'm impressed, I have no idea what that means!\n\n;-)", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 0, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424948, "id": "c02c8m9", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c8m9", "parent_id": "t1_c02c6k2", "body": "Sorry, man, but making a quote that is almost a complete tautology is just plain stupid.  (I'm claiming my nerd points for using the word tautaology!)  Here's on courtesy of mage2k: \"For every difficult and complicated question there is a complex, and \\&lt;paraphrase the word I used before the comma even though using comma there was wrong (especially in a quotation)\\&gt; here, is wrong.\"  Bartelby, here I come!!!  Stating the obvious expert, for hire!  Is there a foreign expression for the opposite of Non Sequitur?", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424974, "body": "\"For every difficult and complicated question there is an answer that is simple, and easily understood and wrong.\" - H.L. Mencken", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02c6k2", "parent_id": "t3_5zffi", "id": "c02c6k2", "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 7, "author": "z5h", "created_utc": "1193764925", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424930, "score": 1, "body": "you keep your prolog, I hate its design and syntax... it has one use, and for everything else it's ugly", "author": "novagenesis", "created_utc": "1193791368", "distinguished": null, "edited": false, "id": "c02c9ye", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02c9ye", "parent_id": "t1_c02c6tl", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "ups": 7, "name": "t1_c02c6tl", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5zffi", "retrieved_on": 1427424971, "score_hidden": false, "body": "If It Does Not Exist, Please Explain\n\nDevelopers writing in \"wrong\" languages like C and Java, have managed to write a lot more \"wrong\" text editors, web browsers, web servers, games, raytracers, databases, word processors, spreadsheets, yadda yadda than all these language preachers could ever hope to write. Probably because they are busy implementing imperative sub language monads in order to read 2 bytes of data.\n\nThe world runs on arrays. Not closures.\n\nAnyway, I'd rather be coding in Prolog.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5zffi", "id": "c02c6tl", "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427424947, "subreddit_id": "t5_2fwo", "created_utc": "1193779485", "ups": 2, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 2, "id": "c02c8nd", "author": "[deleted]", "archived": true, "distinguished": null, "edited": false, "body": "[deleted]", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02c8nd", "parent_id": "t3_5zffi", "score_hidden": false, "author_flair_css_class": null}
{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 0, "author": "rook2pawn", "created_utc": "1193784268", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424929, "score": 1, "id": "c02ca19", "author": "novagenesis", "created_utc": "1193792254", "distinguished": null, "edited": false, "body": "As functional languages go, Perl doesn't provide pattern matching at all.\n\nPattern matching functionally refers to having multiple copies of a function, with specific instances defined....\n\ndef fact 0 = 1\ndef fact n = n * fact(n - 1)\n\nthat's pattern matching... Perl does something arguably better but more insane....takes the arguments however it pleases (including entirely variable arguments, or parsing the argument arbitrarily)\n\nRegular expressions are different.  Regular expressions are evil......\n\nRegular expressions rock!", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02ca19", "parent_id": "t1_c02c97s", "score_hidden": false, "author_flair_css_class": null}, {"controversiality": 0, "retrieved_on": 1427424920, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02cars", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 2, "score_hidden": false, "body": "Yes.  It only works on strings.  What a weird restriction.", "author": "nmessenger", "created_utc": "1193801504", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 2, "parent_id": "t1_c02c97s", "id": "c02cars", "author_flair_css_class": null}], "subreddit": "programming", "score_hidden": false, "ups": 0, "controversiality": 0, "archived": true, "link_id": "t3_5zffi", "retrieved_on": 1427424940, "id": "c02c97s", "author_flair_text": null, "distinguished": null, "edited": false, "name": "t1_c02c97s", "parent_id": "t3_5zffi", "body": "&gt;Pattern matching ... even perl implements a primitive version of it.\r\n\r\nExscuse me? Perl pattern matching is a primitive implementation? ", "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427424937, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c9en", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "score_hidden": false, "body": "[deleted]", "author": "[deleted]", "created_utc": "1193785571", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 1, "parent_id": "t3_5zffi", "id": "c02c9en", "author_flair_css_class": null}
{"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "name": "t1_c02c9go", "gilded": 0, "link_id": "t3_5zffi", "retrieved_on": 1427424937, "score": 1, "id": "c02c9go", "author": "[deleted]", "created_utc": "1193786088", "distinguished": null, "edited": false, "body": "[deleted]", "author_flair_text": null, "subreddit_id": "t5_2fwo", "ups": 1, "parent_id": "t3_5zffi", "score_hidden": false, "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427424937, "subreddit_id": "t5_2fwo", "author_flair_text": null, "name": "t1_c02c9gx", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "score_hidden": false, "id": "c02c9gx", "author": "[deleted]", "created_utc": "1193786174", "distinguished": null, "edited": false, "archived": true, "subreddit": "programming", "ups": 1, "parent_id": "t3_5zffi", "body": "[deleted]", "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427424920, "subreddit_id": "t5_2fwo", "created_utc": "1193801351", "ups": 1, "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "body": "This guy is simply a douchebag. Does he think his thoughts are simpler to get across when he nests ideas 1000 times, or when he runs off on unrelated tangents about feature creep etc. \n\nHe must be wrong!\n\nHe also COMPLETELY ignores hardware and OS. He would rather wax poetic about his fluffy cloud programming idealism, while neglecting the really difficult shit. Scientific Modeling, Operating systems, and other things  where simple is almost never the best solution.\n\nExample: Real numbers are amazing, less complex than the complex numbers! Why would i add 1+0i + 1+0i when i would do 1+1. Therefor, Real numbers are right.\n\nReality: Good luck with electrical engineering without the complex plane. Much less Quantum Physics. ", "author": "[deleted]", "archived": true, "distinguished": null, "edited": true, "id": "c02car2", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02car2", "parent_id": "t3_5zffi", "score_hidden": false, "author_flair_css_class": null}
{"controversiality": 0, "retrieved_on": 1427424897, "subreddit_id": "t5_2fwo", "archived": true, "name": "t1_c02ccl7", "gilded": 0, "link_id": "t3_5zffi", "downs": 0, "score": 1, "score_hidden": false, "body": "[deleted]", "author": "[deleted]", "created_utc": "1193835043", "distinguished": null, "edited": false, "author_flair_text": null, "subreddit": "programming", "ups": 1, "parent_id": "t3_5zffi", "id": "c02ccl7", "author_flair_css_class": null}