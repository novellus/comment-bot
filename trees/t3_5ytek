{"controversiality": 0, "retrieved_on": 1427425831, "subreddit_id": "t5_2fwo", "created_utc": "1193026227", "ups": 2, "gilded": 0, "link_id": "t3_5ytek", "downs": 0, "score": 2, "id": "c02ahyr", "author": "sjf", "archived": true, "distinguished": null, "edited": false, "body": ".. in haskell", "author_flair_text": null, "subreddit": "programming", "name": "t1_c02ahyr", "parent_id": "t3_5ytek", "score_hidden": false, "author_flair_css_class": null}
{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 3, "author": "augustss", "created_utc": "1193043592", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 2, "author": "WouterSwierstra", "created_utc": "1193045355", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 10, "author": "augustss", "created_utc": "1193047510", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 9, "author": "WouterSwierstra", "created_utc": "1193059322", "children": [{"subreddit": "programming", "gilded": 0, "downs": 0, "score": 7, "author": "augustss", "created_utc": "1193060009", "children": [{"subreddit_id": "t5_2fwo", "gilded": 0, "downs": 0, "score": 3, "author": "WouterSwierstra", "created_utc": "1193128804", "children": [{"controversiality": 0, "downs": 0, "subreddit": "programming", "created_utc": "1193131564", "ups": 2, "gilded": 0, "link_id": "t3_5ytek", "retrieved_on": 1427425711, "score": 2, "score_hidden": false, "id": "c02ar6q", "author": "augustss", "author_flair_text": null, "distinguished": null, "edited": false, "archived": true, "subreddit_id": "t5_2fwo", "name": "t1_c02ar6q", "parent_id": "t1_c02ar25", "body": "I agree completely with the goal of showing how easy it can be to do dependent type checking.\nI just think you made it more difficult than it really is, if simplicity is your goal.\n", "author_flair_css_class": null}], "subreddit": "programming", "ups": 3, "name": "t1_c02ar25", "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ytek", "retrieved_on": 1427425713, "score_hidden": false, "id": "c02ar25", "archived": true, "distinguished": null, "edited": true, "parent_id": "t1_c02ajqw", "body": " I think we tried to avoid claiming that everything was oh-so-easy in the paper - it's not. There are all kinds of conferences and workshops dedicated to finding the right notions of binding and substitution; I'd be surprised if we would agree on what the best way to do things is, even in the case for the simply typed lambda calculus. \n\nI think it may come as a surprise to many people that it doesn't need to be much harder than implementing the simply typed lambda calculus. A lot of Haskell programmers seem to refer to \"dependent types\" as some kind of mythical type system that no one could possibly understand. The goal of the paper was to de-mystify dependent types and provide a tutorial in terms that many Haskell programmers can understand, and not to claim inherently hard problems are easy.", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02ajqw", "ups": 7, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ytek", "retrieved_on": 1427425807, "score_hidden": false, "body": "I didn't expect you to agree, if you had then I would have had no complaints. :)\n\nBut I wonder how you can claim it's simple and easy when ypu have BOTH deBruijn indicies (in Term) and HOAS in values?  And there is an eval function for Term.  That seems rather complex and confusing to me to me.\n\nThe title of the paper seems to indicate that you want to show how easy it is; not to make it efficient.  And I just don't think it's as easy as it could have been.\nIf you want to put efficiency into the mix then it becomes a different matter.  Then I have no opinion until I see measurements.\n", "archived": true, "distinguished": null, "edited": false, "parent_id": "t1_c02ajor", "id": "c02ajqw", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02ajor", "score_hidden": false, "controversiality": 0, "archived": true, "ups": 9, "link_id": "t3_5ytek", "retrieved_on": 1427425808, "id": "c02ajor", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02aj2e", "body": "Thanks for your feedback!\n\nI'm not sure I agree with everything. Named variables may seem natural to humans, but defining capture-avoiding substitution, alpha-conversion, etc. can be a bit of a  headache. I don't want to claim de Bruijn indices are perfect; no matter how you represent terms, you're always going to have to do some work. The choice of representation just determines what goes through easily, and what parts require more work.\n\nBy using values and higher-order abstract syntax we don't have to write our own evaluation function. This is a big win, I think. Haskell's evaluator is bound to be quicker than anything we write ourselves (didn't your Lambda Calculus Cooked Four Ways point this out to?). I think that's particularly important if you want to write an efficient type checker for a dependently typed language - as it may need to do quite some evaluation statically. Besides, the quote function and friends may are pretty easy to write compared with eval.\n\nAs for natural numbers, I realize they can be encoded in the system with just Lambda and Pi. If you do this, though, you lose the fact that natural numbers are just first-order data - which is certainly a handy piece of information. By showing how to extend the core language, we were hoping to explain the general pattern of types, introduction rules, and eliminators. Once you get the hang of that, you can probably imagine how a machine can automate the process. It's a shame that Haskell's data types/module system are not strong enough to do this more modularly.", "author_flair_css_class": null}, {"controversiality": 0, "downs": 0, "subreddit": "programming", "archived": true, "ups": 5, "gilded": 0, "link_id": "t3_5ytek", "retrieved_on": 1427425754, "score": 5, "id": "c02anu6", "author": "kosmikus", "created_utc": "1193092711", "distinguished": null, "edited": false, "body": "Just a few remarks from my side: I'm not particularly obsessed with either deBruijn indices or HOAS. In fact, I questioned both approaches during writing the paper. I've tried to write a version without deBruijn indices, but wasn't impressed with it. I think deBruijn indices make the presentation more elegant, even though they're harder to read, but I guess that may just be my personal preference.\n\nI don't think I actually tried to write a version without using HOAS, but maybe I should have. I will try that again.\n\nTo me, both decisions are not the core of the paper. I think they're design decisions you can make one way or the other, and there's not necessarily a single best way. We have tried to make the presentation short and elegant, but of course, elegance is subjective, and we may have missed that goal in your opinion.\n\nThe core of the paper to me is to present _a_ way to a dependently-typed system in a few lines of Haskell code, and to describe all of it without too many references to obscure type theory. I hope that a few people find it interesting enough to download it or reimplement it and start playing with dependent types themselves.\n\nAdding new data types explicitly was a conscious decision, because -- just as Wouter mentioned -- we wanted to show how to do it. I dislike about the current form of the paper that we had to cut the section on adding datatypes down significantly compared to our original plans, due to lack of space. In a rewrite, I'd probably like to expand the stuff that's currently in the Summary of that section and give experimenting with the dependent types more room in the paper.", "author_flair_text": null, "subreddit_id": "t5_2fwo", "name": "t1_c02anu6", "parent_id": "t1_c02aj2e", "score_hidden": false, "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "name": "t1_c02aj2e", "controversiality": 0, "archived": true, "ups": 10, "link_id": "t3_5ytek", "retrieved_on": 1427425816, "id": "c02aj2e", "author_flair_text": null, "distinguished": null, "edited": false, "parent_id": "t1_c02aizp", "body": "A few things:\n\nI don't think deBruijn indicies makes things simpler in total.  If I want to make something simple I just implement substitution with a little bit of alpha-conversion built in and equality with on-th-fly alpha conversion.  It's very easy; no global name generators or anything like that.  Using real variable names is, IMO, more natural and definitely more readable.\n\nI would not use a special types for values (and neutral terms).  It just adds to the number of types and adds strange functions like quote.  (I know it has advantages in that the Haskell type checker can help you more if you make the distinction.  I wonder if phantom types/GADTs could be used to the same effect.)  You really start to notice the overhead when adding more constructors to the term type that then need to be mirrored in the value type.\n\nI'm not sure about the distinction between checkable and inferrable terms either, but that might be good.\n\nIf I were just doing a simple example language I'd not add natural numbers; I'd encode natural numbers in the usual way.  When you keep adding things to the Term type it looks like you've made some bad choice because the Term language is not expressive enough and you have to keep adding things.  (I know this isn't the case, but this was aimed to be a pedagogical example, right?)\n\n", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "score_hidden": false, "ups": 2, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ytek", "retrieved_on": 1427425817, "body": "Care to expand? I'd certainly be interested in your thoughts.", "archived": true, "distinguished": null, "edited": false, "name": "t1_c02aizp", "parent_id": "t1_c02aixj", "id": "c02aizp", "author_flair_css_class": null}], "subreddit_id": "t5_2fwo", "name": "t1_c02aixj", "ups": 3, "controversiality": 0, "author_flair_text": null, "link_id": "t3_5ytek", "retrieved_on": 1427425818, "score_hidden": false, "body": "In my opinion, this is neither the simplest nor easiest way to make a small dependently typed language.", "archived": true, "distinguished": null, "edited": false, "parent_id": "t3_5ytek", "id": "c02aixj", "author_flair_css_class": null}